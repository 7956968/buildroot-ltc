<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Capture Interface &mdash; ISP DDK 2.8.4 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fonts/open-sans/open-sans-font.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.8.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/img.ico"/>
    <link rel="top" title="ISP DDK 2.8.4 documentation" href="../index.html" />
    <link rel="next" title="ISP Control Library" href="../ispc/ispc_library.html" />
    <link rel="prev" title="User Tuning Guide" href="../tuning/user_tuning_guide.html" /> 
  </head>
  <body role="document">
<div id="HeaderContainer">
    <div id="Header">
        <div id="HeaderContent">
            <div id="HeaderLogo">
                <a href="../index.html"><img src="../_static/images/doc-logo.png" /></a>
            </div>
            <div id="ProjectName">
                ISP DDK
            </div>
        </div>
        <div id="searchbox">
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="12" />
              <input type="submit" value="">
            </form>
        </div>
      <div class="clearer"></div>
    </div>
</div>
<div id="NavContainer">
<nav>
    <ul>
        <li id="NavCurrent"><a href="../index.html">Documents</a></li>
        <li><a href="../index/../doxygen/index.html">Source</a>
        <ul>
          <li><a href="../index/../doxygen/pages.html">Related pages</a></li>
          <li><a href="../index/../doxygen/modules.html">Modules</a></li>
          <li><a href="../index/../doxygen/namespaces.html">Namespaces</a></li>
          <li><a href="../index/../doxygen/annotated.html">Data structures</a></li>
          <li><a href="../index/../doxygen/files.html">Files</a></li>
        </ul>
        </li>
    </ul>
</nav>

<div class="clearer"></div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../ispc/ispc_library.html" title="ISP Control Library"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="../tuning/user_tuning_guide.html" title="User Tuning Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Home</a> &raquo;</li><li>Capture Interface</li>
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="capture-interface">
<span id="isp-capture-interface"></span><h1>Capture Interface<a class="headerlink" href="#capture-interface" title="Permalink to this headline">¶</a></h1>
<p>This section is stating some additional information about the Capture
Interface (CI). The CI is the lowest level of the V2500 Software Pipeline
(namely the user and kernel side driver) and deals with the Hardware (HW)
and registers.</p>
<p>The CI folder also contains the external Data Generator driver (DG) that is
the equivalent of the CI used to fake a sensor when running tests on
Imagination&#8217;s FPGA or against the C Simulator (CSIM).</p>
<p>The user-side CI driver also defines the Module Configuration (MC) that
simplifies the configuration of the HW by abstracting some information (such
as the registers precision when they represent real numbers instead of
integers).</p>
<p>Note that V2500 may be referred as <em>felix</em> in this section (its internal
name).</p>
<p>The reader is expected to know about the V2500 architecture and to search
more detail information about the driver in this chapter. The initial section
can also help learning about some of the design objectives of the CI layer.
However the behaviour of the HW should not be explained in that document and
the interaction between CI and other SW elements will not be detailed.</p>
<div class="section" id="design-choices">
<span id="isp-ci-design-choices"></span><h2>Design Choices<a class="headerlink" href="#design-choices" title="Permalink to this headline">¶</a></h2>
<div class="section" id="naming-convention">
<span id="isp-ci-nameing-convention"></span><h3>Naming convention<a class="headerlink" href="#naming-convention" title="Permalink to this headline">¶</a></h3>
<p>The Capture Interface library is composed of several sub-libraries. A single
naming convention is nonetheless used (using capital letters for the library
and camel-case for the object-operation block):</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;library namespace&gt;_&lt;object name&gt;&lt;operation&gt;
</pre></div>
</div>
<p>e.g.: <code class="docutils literal"><span class="pre">CI_PipelineCreate()</span></code></p>
<p>library CI, object Pipeline, operation Create</p>
</div>
<div class="section" id="folder-organisation">
<span id="isp-ci-folder-organisation"></span><h3>Folder organisation<a class="headerlink" href="#folder-organisation" title="Permalink to this headline">¶</a></h3>
<p>It is not obvious how the CI folder is organised. The driver depends on
several libraries, some that are shared among several Imagination
Technologies projects and some that are not. An attempt of separating what
is shared and what is not was made to try to make cross-project building
easier in the future.</p>
<p>Multi-project libraries are directly under <code class="docutils literal"><span class="pre">DDKSource/CI</span></code>:</p>
<ul class="simple">
<li>Target Abstraction Layer (TAL – <code class="docutils literal"><span class="pre">target</span></code> folder) is used to access
registers and device memory (it has many debugging features)</li>
<li>IMG libraries (<code class="docutils literal"><span class="pre">imglib</span></code> folder) are several internal libraries mostly
used by the TAL or other shared components</li>
<li>OSA is an abstraction layer for the operating system used in the TAL for
synchronisation in debug mode</li>
<li><code class="docutils literal"><span class="pre">imgmmu</span></code> is a shared library in IMG for the management of the page
tables of the MMU HW</li>
<li><code class="docutils literal"><span class="pre">transif</span></code> is a shared library in IMG used to abstract the connect to the
simulator when using development drivers</li>
</ul>
<p>Multi-project libraries that are not directly under CI but used by the
low-level driver (in <code class="docutils literal"><span class="pre">DDKSource/common</span></code> folder):</p>
<ul class="simple">
<li>IMG includes (<code class="docutils literal"><span class="pre">DDKSource/common/img_includes</span></code>) are several include files
used in internal libraries to define OS independent data-types and
definitions (like memory allocation). This copes with user and kernel
difference for GNU/Linux as well.</li>
<li>Felix common (<code class="docutils literal"><span class="pre">DDKSource/common/felixcommon</span></code>) that contains pixel format
transformations</li>
<li>Linked list (<code class="docutils literal"><span class="pre">DDKSource/common/linkedlist</span></code>) that contains a linked list
implementation that works in both kernel and user-space</li>
</ul>
<p>The driver related code is under the <code class="docutils literal"><span class="pre">DDKSource/CI/felix</span></code> folder:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">regdefs</span></code> contains the register definitions files specific to V2500 HW</li>
<li><code class="docutils literal"><span class="pre">felix_lib</span></code> is the actual driver (user and kernel side)</li>
<li><code class="docutils literal"><span class="pre">driver_test</span></code> is the test application for <code class="docutils literal"><span class="pre">felix_lib</span></code> see
<a class="reference internal" href="../test_tools/driver_test.html#isp-driver-test"><span>Capture Interface test: driver_test</span></a></li>
</ul>
<p>Finally the actual driver code is in <code class="docutils literal"><span class="pre">DDKSource/CI/felix/felix_lib</span></code> folder:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">data_generator</span></code> contains the user and kernel side of the external DG
driver</li>
<li><code class="docutils literal"><span class="pre">kernel</span></code> contains the kernel side of the CI</li>
<li><code class="docutils literal"><span class="pre">user</span></code> contains the user side (CI and MC)</li>
<li><code class="docutils literal"><span class="pre">testdata</span></code> has a few images used for unit-testing</li>
<li><code class="docutils literal"><span class="pre">test</span></code> contains the unit tests for the library when using it fully in
user-side</li>
<li><code class="docutils literal"><span class="pre">utils</span></code> contains the code used for the simple DPF write map to read map
converter (see <a class="reference internal" href="../test_tools/dpf_conv.html#isp-dpf-conv"><span>Defective Pixel output converter: dpf_conv</span></a>) and an IOCTL printer.</li>
</ul>
</div>
<div class="section" id="libraries-and-namespaces">
<span id="isp-ci-libraries-and-namespaces"></span><h3>Libraries and namespaces<a class="headerlink" href="#libraries-and-namespaces" title="Permalink to this headline">¶</a></h3>
<p>The CI layer is in fact composed of several “libraries” that interact with
each-others as shown in <a class="reference internal" href="#isp-ci-capture-interface-ecosystem-fig"><span>The Capture Interface eco-system</span></a>.</p>
<div class="figure" id="id35">
<span id="isp-ci-capture-interface-ecosystem-fig"></span><a class="reference internal image-reference" href="../_images/CI_Ecosystem.png"><img alt="../_images/CI_Ecosystem.png" src="../_images/CI_Ecosystem.png" style="width: 215px; height: 297px;" /></a>
<p class="caption"><span class="caption-text">The Capture Interface eco-system</span></p>
</div>
<p>In user space:</p>
<ul class="simple">
<li>Capture Interface (<code class="docutils literal"><span class="pre">CI</span></code>) is the library to access the V2500 driver</li>
<li>Module Configuration (<code class="docutils literal"><span class="pre">MC</span></code>) is the very thin library on top of CI to
help configuring the CI modules</li>
<li>Data Generator (<code class="docutils literal"><span class="pre">DG</span></code>) is the library to access the V2500 external Data
Generator driver</li>
</ul>
<p>In kernel space both CI and DG are separated in several namespaces but built in
the same kernel module</p>
<ul class="simple">
<li>Interaction (<code class="docutils literal"><span class="pre">INT_CI</span></code>, <code class="docutils literal"><span class="pre">INT_DG</span></code>) functions called from user-space
through system calls (<code class="docutils literal"><span class="pre">ioctl()</span></code>, <code class="docutils literal"><span class="pre">memmap()</span></code>, ...)</li>
<li>Kernel (<code class="docutils literal"><span class="pre">KRN_CI</span></code>, <code class="docutils literal"><span class="pre">KRN_DG</span></code>) functions called from kernel-space and
that handle the logic of the drivers</li>
<li>Hardware (<code class="docutils literal"><span class="pre">HW_CI</span></code>, <code class="docutils literal"><span class="pre">HW_DG</span></code>) functions that deal with the register or
device memory</li>
<li>Device (<code class="docutils literal"><span class="pre">DEV_CI</span></code>, <code class="docutils literal"><span class="pre">DEV_DG</span></code>) functions that are called by the OS to
handle system calls on kernel-side</li>
<li>System (<code class="docutils literal"><span class="pre">SYS</span></code>) is a mini library that abstracts some of the operating
system behaviour. Its goal is to mimic the GNU/Linux kernel interface that
can be implemented for other OS in the future (and also used for debug
purposes in user-space using posix). For example locks are implemented in
that layer.</li>
<li>Platform (<code class="docutils literal"><span class="pre">Platform</span></code>) is used to represent platform specific
functionalities for the device management and allocation of memory. More
information about these functions is available in the
<a class="reference internal" href="../integration/platform.html#isp-platform-integration-guide"><span>Platform Integration Guide</span></a> chapter.</li>
<li>It is also possible that some internal local function will be prefixed
with <code class="docutils literal"><span class="pre">IMG</span></code>, showing that they should not be called outside of their file.</li>
</ul>
</div>
<div class="section" id="fake-and-real-driver">
<span id="isp-ci-fake-and-real-driver"></span><h3>Fake and Real driver<a class="headerlink" href="#fake-and-real-driver" title="Permalink to this headline">¶</a></h3>
<p>The driver is developed while running against the C Simulator (bit accurate
HW simulator) and most of the time this is done fully in user-space (to
allow easier debugging). This mode is called fake because the device does
not really exist. Some mechanisms were created to replace what is normally
provided by the Linux Kernel or by the HW.</p>
<ul class="simple">
<li>Fake IOCTL calls (that directly map to kernel side – see
<a class="reference internal" href="#isp-ci-user-kernel-interactions"><span>User/Kernel interactions</span></a>)</li>
<li>Fake interrupt handling (that does not stop other threads from running)</li>
</ul>
<p>The driver is therefore considered <em>real</em> if it is running as a kernel module
or compiled as part of the GNU/Linux kernel.</p>
<p>This is implemented in the <code class="docutils literal"><span class="pre">SYS_IO</span></code> namespace (in user-space), composed one
function per system call:</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/sys__userio_8c.html#a55e9913e4f67dc0453527e6d8aa42a75">SYS_IO_Open()</a> abstracts <code class="docutils literal"><span class="pre">open()</span></code></li>
<li><a class="reference external" href="../doxygen/sys__userio__fake_8c.html#a73423b8c85000202fa018a7e664db4b0">SYS_IO_Close()</a> abstracts <code class="docutils literal"><span class="pre">close()</span></code></li>
<li><a class="reference external" href="../doxygen/sys__userio__fake_8c.html#a178654b51bba9bfc0f85570f3661f831">SYS_IO_Control()</a> abstracts <code class="docutils literal"><span class="pre">ioctl()</span></code></li>
<li><a class="reference external" href="../doxygen/sys__userio__fake_8c.html#a2ac6ac3c124b1b4686fc7089de36515b">SYS_IO_MemMap2()</a> abstracts <code class="docutils literal"><span class="pre">mmap2()</span></code> or <code class="docutils literal"><span class="pre">mmap()</span></code></li>
<li><a class="reference external" href="../doxygen/sys__userio_8h.html#a02af4666619b5d6477fc36bf3066f5c0">SYS_IO_MemUnmap()</a> abstracts <code class="docutils literal"><span class="pre">munmap()</span></code></li>
</ul>
<p>When running the Fake implementation a structure is provided when calling
<a class="reference external" href="../doxygen/sys__userio_8c.html#a55e9913e4f67dc0453527e6d8aa42a75">SYS_IO_Open()</a> with one pointer to function per system call. These
functions will be called instead of the real system calls and their
prototypes are expected on the kernel side. The interaction is
described in <a class="reference internal" href="#isp-ci-fake-system-call-fig"><span>Fake System-call</span></a> and
<a class="reference internal" href="#isp-ci-real-system-call-fig"><span>Real System-call (GNU/Linux)</span></a>.</p>
<div class="figure" id="id36">
<span id="isp-ci-fake-system-call-fig"></span><a class="reference internal image-reference" href="../_images/CI_Fake_System_Call.png"><img alt="../_images/CI_Fake_System_Call.png" src="../_images/CI_Fake_System_Call.png" style="width: 400px; height: 70px;" /></a>
<p class="caption"><span class="caption-text">Fake System-call</span></p>
</div>
<div class="figure" id="id37">
<span id="isp-ci-real-system-call-fig"></span><a class="reference internal image-reference" href="../_images/CI_Real_System_Call.png"><img alt="../_images/CI_Real_System_Call.png" src="../_images/CI_Real_System_Call.png" style="width: 538px; height: 101px;" /></a>
<p class="caption"><span class="caption-text">Real System-call (GNU/Linux)</span></p>
</div>
</div>
</div>
<div class="section" id="limitations">
<span id="isp-ci-limitations"></span><h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="isp-ci-identifiers">
<span id="identifiers"></span><h3>Identifiers<a class="headerlink" href="#isp-ci-identifiers" title="Permalink to this headline">¶</a></h3>
<p>Each &#8220;connection&#8221; to the driver (i.e. each call to <code class="docutils literal"><span class="pre">open()</span></code> through
<a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#ga32f2d72505f1ac25503ce41edbd6a665">CI_DriverInit()</a>) can only have a limited number of &#8220;elements&#8221;:</p>
<ul>
<li><p class="first">Each created Pipeline object has a unique identifier relative to
its parent Connection as an <code class="docutils literal"><span class="pre">int</span></code>.</p>
<p>This identifier relates the <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> given to the user to the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html">KRN_CI_PIPELINE</a> one stored in the kernel. Identifiers are stored in
a user-space private structure: <a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html">INT_PIPELINE</a>.</p>
</li>
<li><p class="first">Each buffer mapped from kernel-side to user-side has a unique identifier
relative to its parent Connection as an <code class="docutils literal"><span class="pre">int</span></code>.</p>
<p>This identifier allows the user-space to associate the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a> and <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a> to a <a class="reference external" href="../doxygen/struct_c_i___s_h_o_t.html">CI_SHOT</a> and the
memory it needs through some user-side internal structures:
<a class="reference external" href="../doxygen/struct_i_n_t___b_u_f_f_e_r.html">INT_BUFFER</a> and <a class="reference external" href="../doxygen/struct_i_n_t___s_h_o_t.html">INT_SHOT</a>.</p>
</li>
</ul>
<p>Signed integers are used for both unique IDs, this means that if more than
<code class="docutils literal"><span class="pre">INT_MAX</span></code> objects are created in a single connection the kernel driver may
confuse two elements. Overflow of signed integer ID is not allowed since it
is very unlikely to happen (the driver will fail if it happens).</p>
<p>Typically <code class="docutils literal"><span class="pre">off_t</span></code> is used when doing sharing memory from kernel-side to
user-side as it is the parameter to <code class="docutils literal"><span class="pre">mmap()</span></code>. However to support Android
versions which may have a 64b kernel and 32b user-space we chose to use that
offset as an <code class="docutils literal"><span class="pre">int</span></code>.</p>
<p>For example the maximum values for a GNU/Linux system (<code class="docutils literal"><span class="pre">PAGESIZE</span></code> is 4096):</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System</th>
<th class="head">INT_MAX</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>32b</td>
<td>2,147,483,647</td>
</tr>
<tr class="row-odd"><td>64b</td>
<td>2,147,483,647</td>
</tr>
</tbody>
</table>
<p>Therefore the maximum number of Pipeline object to be created per call to
<code class="docutils literal"><span class="pre">open()</span></code> is a bit more than 2 billion. More than one buffer is allocated
for a single frame capture (e.g. encoder, display, DPF, HDR Extraction,
statistics) but even if we assume we need 10 &#8220;mappable&#8221; elements per frame
to capture it is still more than 200 million unique buffers per call to
<code class="docutils literal"><span class="pre">open()</span></code> (in a world where a unique buffer would be allocated for every
frame of a video at 60 FPS it is a bit less than 1,000 h of video).</p>
</div>
<div class="section" id="linux-kernel-trouble">
<span id="isp-ci-linux-kernel-trouble"></span><h3>Linux Kernel Trouble<a class="headerlink" href="#linux-kernel-trouble" title="Permalink to this headline">¶</a></h3>
<p>Known trouble with some Linux kernel libraries used by the driver.</p>
<div class="section" id="memory-band-management-genalloc">
<span id="isp-ci-memory-band-management"></span><h4>Memory band management (<code class="docutils literal"><span class="pre">genalloc</span></code>)<a class="headerlink" href="#memory-band-management-genalloc" title="Permalink to this headline">¶</a></h4>
<p>Linux kernel 3.2.0 contains defects in <code class="docutils literal"><span class="pre">genalloc.c</span></code> triggered when using the
MMU Heap implementation.</p>
<ul>
<li><p class="first">Allocating a bloc using <code class="docutils literal"><span class="pre">gen_pool_alloc()</span></code> returns 0 on error, which is
problematic when the 1st valid address is 0.</p>
<p>This is solved by shifting the address range by a page when the pool is
created or by not using the 1st band of memory.</p>
</li>
<li><p class="first">In kernel versions prior to 3.12 gen_pool_add_virt() was computing as:</p>
<div class="highlight-python"><div class="highlight"><pre>chunk-&gt;end_addr = virt + size; // (size_t size, phys_addr_t phys)
</pre></div>
</div>
<p>On 32b machines this could result in an overflow if using the last page of
the system.</p>
</li>
</ul>
<p>The V2500 driver’s virtual heaps therefore avoid the 1st and last page of
the device MMU.</p>
</div>
</div>
</div>
<div class="section" id="hw-modules-and-resources">
<span id="isp-ci-hw-modules-and-resources"></span><h2>HW Modules and resources<a class="headerlink" href="#hw-modules-and-resources" title="Permalink to this headline">¶</a></h2>
<p>This section highlights how the driver handles the HW resources and modules.</p>
<div class="section" id="hw-resources">
<span id="isp-ci-hw-resources"></span><h3>HW Resources<a class="headerlink" href="#hw-resources" title="Permalink to this headline">¶</a></h3>
<p>The driver considers that the HW can provide several &#8220;resources&#8221; which are
not shareable between several processes. These resources are:</p>
<ul class="simple">
<li>HW Context (the HW has <a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html#ac5ef31ff6f4d20b235736f57a6123485">CI_HWINFO::config_ui8NContexts</a> of them)</li>
<li>HW Gaskets (the HW has <a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html#ab032bc3a3fb6e8c2763a0179152802ae">CI_HWINFO::config_ui8NImagers</a> of them)</li>
<li>If present HW Internal Data Generator (the HW has
<a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html#a71ccf49d5ba0042404f1b00a9e084780">CI_HWINFO::config_ui8NIIFDataGenerator</a> of them)</li>
<li>If present HW External Data Generator (the HW has
<a class="reference external" href="../doxygen/struct_d_g___h_w_i_n_f_o.html#a601de0b844bee2a7c1b24e474c2c9d5f">DG_HWINFO::config_ui8NDatagen</a> of them)</li>
<li>The linestore is shared between HW Context and therefore handled globally</li>
<li>The GMA look-up table is shared between HW Context and therefore handled
globally</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html">CI_HWINFO</a> is accessible in user-space as part of
<a class="reference external" href="../doxygen/struct_c_i___c_o_n_n_e_c_t_i_o_n.html#a15958f8c59d3fa65ef1d138f190a469a">CI_CONNECTION::sHWInfo</a>.</p>
</div>
</div>
<div class="section" id="line-store">
<span id="isp-ci-linestore"></span><h3>Line-store<a class="headerlink" href="#line-store" title="Permalink to this headline">¶</a></h3>
<p>The line-store configuration is used by some HW module to know the number of
lines to store for the computation of the module. The driver is responsible
for setting up the size of the stored lines. The HW expects 1 line-store
start position for each context. The driver stores additional information
such as the size (that is either until another line-store start is found or
to the maximum possible for this context).</p>
<p>It is likely that the line-store should not be modified often as its
configuration certainly depends on the size of the sensors.</p>
<div class="section" id="hw-knowledge">
<span id="isp-ci-linestore-hw-knowledge"></span><h4>HW Knowledge<a class="headerlink" href="#hw-knowledge" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">The maximum size of a context is defined in a register (accessible in
<a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html">CI_HWINFO</a> structure)</p>
<p>This maximum size is the maximum size from the start point (it can be
anywhere in the line-store buffer.</p>
</li>
<li><p class="first">The total size of the line-store buffer is the maximum size across all
context’s sizes (usually the context 0 is the biggest)</p>
</li>
<li><p class="first">The line-store <strong>cannot</strong> be changed whilst a context is capturing</p>
</li>
</ul>
<ul id="isp-ci-linestore-sw-knowledge">
<li><p class="first">The line-store configuration is stored globally; this means that any user
connected to the device can ask to change it.</p>
</li>
<li><p class="first">Modifying the line-store in the driver is expensive (all contexts are
locked in the driver).</p>
<p>If modifications have to be made on the line-store it is recommended to
update it from the driver first (to get modification other could have done).</p>
</li>
<li><p class="first">Updating a local copy of the line-store is relatively cheap but still
involves locking (each context is locked one at a time just to copy the
configuration values).</p>
</li>
<li><p class="first">Initially the line-store is set-up to be shared equally among contexts.</p>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">LS_BUFFER_ALLOCATION</span></code> register is written to when the capture is
started (before setting up the <code class="docutils literal"><span class="pre">CONTEXT_CONTROL</span></code>). At this point the value
is converted from pixels to &#8220;pairs of pixels&#8221; as the register expects.</p>
</li>
<li><p class="first">The driver can refuse a capture start if there is not enough room in the
HW linestore to let it start or if the context position given by user-space
overlaps with one an already started context.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Locking is software locking only.</p>
</div>
</div>
<div class="section" id="hw-context-and-ci-pipeline-object">
<span id="isp-ci-hw-context-and-ci-pipeline"></span><h4>HW Context and <code class="docutils literal"><span class="pre">CI_PIPELINE</span></code> object<a class="headerlink" href="#hw-context-and-ci-pipeline-object" title="Permalink to this headline">¶</a></h4>
<p>In user-space several <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> objects can be created. The number
is not limited by any HW features. However when registered a Pipeline object
selects on which HW context it will require to run
(<span>CI_PIPELINE::ui8Context</span>). When starting the capture the
kernel-module will try to associate a Pipeline object to its desired HW
context. Only 1 Pipeline object can be running on a HW Context so the
capture may fail to start if it is already used by another object (from the
same process or a different process).</p>
</div>
<div class="section" id="hw-gasket-and-ci-gasket-object">
<span id="isp-ci-hw-gasket-and-ci-gasket"></span><h4>HW Gasket and <code class="docutils literal"><span class="pre">CI_GASKET</span></code> object<a class="headerlink" href="#hw-gasket-and-ci-gasket-object" title="Permalink to this headline">¶</a></h4>
<p>The user-space CI library provides a <a class="reference external" href="../doxygen/struct_c_i___g_a_s_k_e_t.html">CI_GASKET</a> object that is used to
configure the gasket when starting the sensor. It has to be reserved and
only 1 connection (call to <code class="docutils literal"><span class="pre">open()</span></code>) can hold a gasket at any given time.</p>
</div>
<div class="section" id="hw-internal-data-generator-and-ci-datagen-object">
<span id="isp-ci-hw-internal-dg-and-ci-datagen"></span><h4>HW Internal Data Generator and <code class="docutils literal"><span class="pre">CI_DATAGEN</span></code> object<a class="headerlink" href="#hw-internal-data-generator-and-ci-datagen-object" title="Permalink to this headline">¶</a></h4>
<p>The user-space CI library provides a <a class="reference external" href="../doxygen/struct_c_i___d_a_t_a_g_e_n.html">CI_DATAGEN</a> object that can be
used to configure the internal Data Generator if it is available (available
if <a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html#afc105bffd16a49747840c0340ce696b2">CI_HWINFO::eFunctionalities</a> has the
<code class="docutils literal"><span class="pre">CI_INFO_SUPPORTED_IIF_DATAGEN</span></code> bit set).</p>
<p>As per the Pipeline objects several can be created for the available HW but
only 1 can run per HW resource.</p>
</div>
<div class="section" id="hw-external-data-generator-and-dg-camera-object">
<span id="isp-ci-hw-external-dg-and-dg-camera"></span><h4>HW External Data Generator and <code class="docutils literal"><span class="pre">DG_CAMERA</span></code> object<a class="headerlink" href="#hw-external-data-generator-and-dg-camera-object" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="../doxygen/struct_d_g___c_a_m_e_r_a.html">DG_CAMERA</a> objects are similar to the <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a>. There is
not limitation on how many can be created by user-space but they can only be
associated to 1 running HW data generator. They are used to convert a given
file to the memory format expected by the HW module.</p>
</div>
</div>
<div class="section" id="gamma-correction">
<span id="isp-ci-gamma-correction"></span><h3>Gamma Correction<a class="headerlink" href="#gamma-correction" title="Permalink to this headline">¶</a></h3>
<p>This section is about the Gamma Correction Look-up table (also called Gamma
curve). It is recommended to read the TRM section about Gamma correction to
fully understand this HW block.</p>
<div class="section" id="isp-ci-gamma-hw-knowledge">
<span id="id1"></span><h4>HW Knowledge<a class="headerlink" href="#isp-ci-gamma-hw-knowledge" title="Permalink to this headline">¶</a></h4>
<p>The Gamma Look Up table register bank the V2500 is shared among all the
contexts. Therefore it is not recommended that the user changes the values
while any context is running (one may use an incomplete curve). Each context
can however choose to enable the usage of this table individually for each
frame (part of the load structure).</p>
<p>By design the GMA LUT is 63 points to represent the whole Gamut range. Because
the HW can support extended Gammut the signal range is [-0.5 ; 1.5]. The HW block
handles 11 bits, therefore the whole range is [0 ; 3071].</p>
<p>The GMA LUT registers are representing the whole input on a non-evenly spaced
subsampling of the curve:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="8%" />
<col width="18%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2">Input Range</th>
<th class="head">Knee points</th>
<th class="head">Points</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>31</td>
<td>2</td>
<td>0;  15</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>63</td>
<td>4</td>
<td>32;  39;  47;  55</td>
</tr>
<tr class="row-even"><td>64</td>
<td>127</td>
<td>4</td>
<td>64;  79;  95; 111</td>
</tr>
<tr class="row-odd"><td>128</td>
<td>255</td>
<td>4</td>
<td>128; 159; 191; 223</td>
</tr>
<tr class="row-even"><td>256</td>
<td>511</td>
<td>8</td>
<td>256; 287; 319; 351; 383; 415; 447; 479</td>
</tr>
<tr class="row-odd"><td>512</td>
<td>1023</td>
<td>8</td>
<td>512; 575; 639; 703; 767; 831; 895; 959</td>
</tr>
<tr class="row-even"><td>1024</td>
<td>3071</td>
<td>32</td>
<td><p class="first">1024; 1087; 1151; 1215; 1279; 1343; 1407; 1471</p>
<p>1535; 1599; 1663; 1727; 1791; 1855; 1919; 1983</p>
<p>2047; 2111; 2175; 2239; 2303; 2367; 2431; 2495</p>
<p class="last">2559; 2623; 2687; 2751; 2815; 2879; 2943; 3007</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="driver-limitations">
<span id="isp-ci-gamma-driver-limitations"></span><h4>Driver Limitations<a class="headerlink" href="#driver-limitations" title="Permalink to this headline">¶</a></h4>
<p>The driver was designed with the assumption that the GMA curve is
representing a standard and, because it is shared amongst all HW contexts,
is not intended to be changed unless trying calibration for different
standards.</p>
<p>It would have been technically possible to change the GMA curve every-time a
context requests a capture to start but because of the assumption that the
standard curve does not change it would have involved unnecessary checking.</p>
<p>The driver initialises the default curve at the creation of the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___d_r_i_v_e_r.html">KRN_CI_DRIVER</a> object when <code class="docutils literal"><span class="pre">insmod</span></code> is invoked. It is possible to
change which default curve is used at that time (see <a class="reference internal" href="../getting_started.html#isp-gsg-insmod-options"><span>Getting Started
Guide</span></a>). See <a class="reference internal" href="#isp-ci-gamma-lut-customisation"><span>Gamma Look-Up table customisation</span></a>
to know how to change the default and values.</p>
<p>The CI interface in user space allows the retrieving of the current curve
but also the override of the curve. The current value of the Gamma LUT can
be read in the given <a class="reference external" href="../doxygen/struct_c_i___c_o_n_n_e_c_t_i_o_n.html">CI_CONNECTION</a>. The value can be updated using
<a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#gace5141674b6d3212187a4eceb775134b">CI_DriverGetGammaLUT()</a> (get updated version from the kernel-side) or
<a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#ga4fb779117778eb1f08c6d99700614304">CI_DriverSetGammaLUT()</a> (propose LUT from the user-side).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not recommended that the user changes the Gamma curve using that
method (changing the default one is safer).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The Gamma LUT <strong>cannot</strong> be changed while any context is capturing,
therefore proposing a new table may not work all the time.</p>
</div>
<p>The driver should have a curve for the BT709 and the sRGB standards. These
curves were generated from the standard <em>formulae</em> and modified to limit the
error of the approximation when converted to our register format (see
<a class="reference internal" href="#isp-ci-gamma-lut-fig"><span>Default Gamma Look-Up tables (BT709 and sRGB)</span></a>). The values are available in
<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga370dddc4719aee3e330a71b05048edf2">KRN_CI_DriverDefaultsGammaLUT()</a>, in <code class="docutils literal"><span class="pre">kernel_src/ci_internal.c</span></code>.</p>
<div class="figure" id="id38">
<span id="isp-ci-gamma-lut-fig"></span><img alt="../_images/CI_GMA_LUT.png" src="../_images/CI_GMA_LUT.png" />
<p class="caption"><span class="caption-text">Default Gamma Look-Up tables (BT709 and sRGB)</span></p>
</div>
</div>
<div class="section" id="gamma-look-up-table-customisation">
<span id="isp-ci-gamma-lut-customisation"></span><h4>Gamma Look-Up table customisation<a class="headerlink" href="#gamma-look-up-table-customisation" title="Permalink to this headline">¶</a></h4>
<p>This section contains information about the GMA LUT registers and how to
change the default curve or add other curves to the driver.</p>
<div class="section" id="change-the-default-curve">
<h5>Change the default curve<a class="headerlink" href="#change-the-default-curve" title="Permalink to this headline">¶</a></h5>
<p>The default used curve is specified in <a class="reference external" href="../doxygen/ci__kernel_8h.html">ci_kernel.h</a> with the macro
<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gaf38f4a94d112124185ddfbcc14411a7a">CI_DEF_GMACURVE</a>. If this value is change make sure
<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga370dddc4719aee3e330a71b05048edf2">KRN_CI_DriverDefaultsGammaLUT()</a> can support the new value or every
<code class="docutils literal"><span class="pre">insmod</span></code> without the gammaCurve parameter will fail.</p>
</div>
<div class="section" id="add-other-curves">
<h5>Add other curves<a class="headerlink" href="#add-other-curves" title="Permalink to this headline">¶</a></h5>
<p>Using the register values from the HW documentation it should be possible to
generate alternative curves and add them to
<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga370dddc4719aee3e330a71b05048edf2">KRN_CI_DriverDefaultsGammaLUT()</a> in <code class="docutils literal"><span class="pre">kernel_src/ci_internal.c</span></code>. The
current implementation uses the same values for the Red, Green and Blue
channels but the values could be different.</p>
<p>The <a class="reference internal" href="../test_tools/vision_live_2.html#isp-vl2-modulegma"><span>Vision Live tool</span></a> provided can help generate
register values.</p>
</div>
</div>
</div>
<div class="section" id="deshading-grid-lens-shading">
<span id="isp-ci-deshading-grid"></span><h3>Deshading Grid (Lens shading)<a class="headerlink" href="#deshading-grid-lens-shading" title="Permalink to this headline">¶</a></h3>
<p>The deshading grid (also called matrix) is a part of the Lens Shading module
(LSH) that is loaded from device memory. It is stored in a specific format
described in the TRM.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>It is important to read and understand the TRM about the LSH block
memory format to fully comprehend the following section.</p>
<p>The details about are covered in the TRM:</p>
<ul class="simple">
<li>relationship between sensor resolution, tile-size and grid size</li>
<li>memory format used by the HW (with bits per difference, line size and
stride)</li>
<li>skip and offset values to handle decimation and cropping from the IIF</li>
</ul>
<p>The module also has size limitations that are verified in
<a class="reference external" href="../doxygen/group___c_i___a_p_i___m_o_d.html#ga640d8e4ad1fca2290052c964d9d0c1e1">CI_ModuleLSH_verif()</a>.</p>
<p>The understanding HW format can be simplified to the following (per line):</p>
<ul class="last simple">
<li>one 16b initial fix point coefficient, followed by</li>
<li>several differential values encoded on [LSH_DELTA_BITS_MIN ;
LSH_DELTA_BITS_MAX] bits (usually 4 to 10). The actual number of bits
can be chosen by SW.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>It is important to remember that the LSH HW block has several
responsibilities:</p>
<ul class="simple">
<li>correct the de-shading effect (configured in SW by LSH module)</li>
<li>apply White Balance gains and clip (configured in SW by the WBC module)</li>
<li>apply the system black level (configured in SW by the BLC module)</li>
</ul>
<p class="last">The TRM will detail the order of the operations and which registers are
related to which operation.</p>
</div>
<div class="section" id="lsh-grid-from-user-space">
<span id="isp-ci-lsh-user-space"></span><h4>LSH grid from user-space<a class="headerlink" href="#lsh-grid-from-user-space" title="Permalink to this headline">¶</a></h4>
<p>From user-space the following functions are used the control the de-shading
grid:</p>
<ul>
<li><p class="first"><a class="reference external" href="../doxygen/ci__api_8h.html#a430993375aa1f8a39ed63a4d1d1a80cb">CI_PipelineAllocateLSHMatrix()</a>
Allocate a deshading grid with a given size in Bytes. The computation of the
required size for a grid is explained later.</p>
<p>This returns a matrix identifier that should be used for all other functions.
The matrix ID 0 is invalid.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/ci__pipeline_8c.html#a85effb9816ae07f9707a0c7add259c6d">CI_PipelineDeregisterLSHMatrix()</a>
Free a deshading grid.</p>
<p>Can only be performed if the selected grid is not in use.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/ci__pipeline_8c.html#ab40e9a4424efc335df9a79e24d3185bc">CI_PipelineAcquireLSHMatrix()</a> gives access to an already allocated
deshading grid. The grid should then be released using
<a class="reference external" href="../doxygen/ci__pipeline_8c.html#ad6b7bc1e9fddc2cea89396eff40f4ba8">CI_PipelineReleaseLSHMatrix()</a>.</p>
<p>The matrix currently used cannot be acquired.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/ci__pipeline_8c.html#a1c46330eb89a055f63f0432f9f6037a6">CI_PipelineUpdateLSHMatrix()</a> to change the matrix currently in use.
If the given matrix identifier is 0 then disables the usage of the LSH grid.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/ci__pipeline_8c.html#aaed1319c4a23a29fa47cb001df54b274">CI_PipelineHasLSHBuffers()</a> can be used to count the number of
allocated matrices.</p>
</li>
</ul>
<p>All these functions expect to deal with the HW memory format as it is stored
in a <a class="reference external" href="../doxygen/struct_c_i___l_s_h_m_a_t.html">CI_LSHMAT</a> structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">CI_LSHMAT</span>
<span class="p">{</span>
    <span class="cm">/** @brief matrix identifier - do not modify */</span>
    <span class="n">IMG_UINT32</span> <span class="n">id</span><span class="p">;</span>
    <span class="cm">/** @brief pointer to user-side accessible data in HW format */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/** @brief Size in Bytes */</span>
    <span class="n">IMG_UINT32</span> <span class="n">ui32Size</span><span class="p">;</span>
    <span class="cm">/** @brief Associated configuration */</span>
    <span class="n">CI_MODULE_LSH_MAT</span> <span class="n">config</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CI_LSHMAT</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">CI_MODULE_LSH_MAT</span>
<span class="p">{</span>
    <span class="cm">/** @note Load Structure: LSH_ALIGNMENT:LSH_SKIP_X */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16SkipX</span><span class="p">;</span>
    <span class="cm">/** @note Register: LSH_OFFSET:LSH_SKIP_Y */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16SkipY</span><span class="p">;</span>

    <span class="cm">/** @note Load Structure: LSH_ALIGNMENT:LSH_OFFSET_X */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16OffsetX</span><span class="p">;</span>
    <span class="cm">/** @note Register: LSH_OFFSET:LSH_OFFSET_Y */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16OffsetY</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * @brief The mesh size - a power of 2 in range of</span>
<span class="cm">     * [LSH_DELTA_BITS_MIN ; LSH_DELTA_BITS_MAX]</span>
<span class="cm">     *</span>
<span class="cm">     * @note Register: LSH_GRID_TILE:TILE_SIZE_LOG2</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT8</span> <span class="n">ui8TileSizeLog2</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * @brief Number of bits to use to store the differences</span>
<span class="cm">     *</span>
<span class="cm">     * @note Load Structure: LSH_GRID:LSH_VERTEX_DIFF_BITS</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT8</span> <span class="n">ui8BitsPerDiff</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * @brief Number of elements in a line of deshading grid</span>
<span class="cm">     * (including the 1st full 16b element)</span>
<span class="cm">     *</span>
<span class="cm">     * @note Not written to registers, @see ui16LineSize</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16Width</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * @brief Number of lines in the deshading grid.</span>
<span class="cm">     *</span>
<span class="cm">     * @note Not written to registers, the HW reads as many lines as needed</span>
<span class="cm">     * according to the IIF output</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16Height</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * @brief Number of elements in the matrix line in units of 16 bytes</span>
<span class="cm">     * minus 1</span>
<span class="cm">     * - related to ui16TileSize and the image&#39;s size</span>
<span class="cm">     *</span>
<span class="cm">     * @warning IN UNITS OF 16 BYTES</span>
<span class="cm">     *</span>
<span class="cm">     * @note Register: LSH_GRID_LINE_SIZE:LSH_GRID_LINE_SIZE</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16LineSize</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * @brief The matrix stride (per channel) in bytes</span>
<span class="cm">     *</span>
<span class="cm">     * @note Register: LSH_GRID_STRIDE:LSH_GRID_STRIDE</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT32</span> <span class="n">ui32Stride</span><span class="p">;</span>

<span class="p">}</span> <span class="n">CI_MODULE_LSH_MAT</span><span class="p">;</span>
</pre></div>
</div>
<p>Populating the field of that structure from user space can be done manually but
it is recommended to use the helper functions from the MC level that take
advantage of the FelixCommon <a class="reference external" href="../doxygen/struct_l_s_h___g_r_i_d.html">LSH_GRID</a> structure that simplifies the
access to a grid:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">LSH_GRID</span>
<span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * @brief tiles are square. width &gt;= imager_width/tiles_size and</span>
<span class="cm">     * height &gt;= imager_height/tile_size</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16TileSize</span><span class="p">;</span>
    <span class="cm">/** @brief in &quot;tiles&quot; */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16Width</span><span class="p">;</span>
    <span class="cm">/** @brief in rows of tiles */</span>
    <span class="n">IMG_UINT16</span> <span class="n">ui16Height</span><span class="p">;</span>

    <span class="cm">/** @brief a ui16Width*ui16Height matrix for each channel */</span>
    <span class="n">LSH_FLOAT</span> <span class="o">*</span><span class="n">apMatrix</span><span class="p">[</span><span class="n">LSH_MAT_NO</span><span class="p">];</span>
<span class="p">}</span> <span class="n">LSH_GRID</span><span class="p">;</span>
</pre></div>
</div>
<p>FelixCommon also provides several functions to handle the structure.</p>
<ul>
<li><p class="first"><a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gac5766eb5833f0cec93b61b7fb0efa796">LSH_CreateMatrix()</a> or <a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#ga7f8cb2e26eb1966962cb53aeede3c367">LSH_AllocateMatrix()</a>. Respectively to
create a matrix when the sensor&#8217;s resolution is known or allocate a matrix
when the size of the matrix is actually known.</p>
<p>Either way the matrix should be deleted using <a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#ga8602da77c404198f93711fa0cde4b3c8">LSH_Free()</a>.</p>
</li>
<li><p class="first">For testing purposes <a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gaae7dddebe8af11ee38ad84b4632d20b0">LSH_FillLinear()</a> or <a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gad0cdb265f45225d7789f521c656ef39b">LSH_FillBowl()</a> can be
used to fill different channels with data.</p>
</li>
<li><p class="first">Or matrices can be loaded or saved from files using <a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gaf0388418bf6319219c585203ce81f203">LSH_Load_bin()</a> and
<a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gadd8f391439bcf98de8b8347aa9a54310">LSH_Save_bin()</a>. The details about the file format are available in the
<a class="reference internal" href="../test_tools/test_tools.html#isp-tt-deshading-grid"><span>Deshading Grid file format (LSH)</span></a> section.</p>
</li>
</ul>
<p>The MC layer can also be used to get information about <a class="reference external" href="../doxygen/struct_l_s_h___g_r_i_d.html">LSH_GRID</a> and
transform it to relevant information to fill the <a class="reference external" href="../doxygen/struct_c_i___l_s_h_m_a_t.html">CI_LSHMAT</a> properly.
The main one being <a class="reference external" href="../doxygen/group___m_c.html#ga449be20387bba0a26da5171f5ba3aa6c">MC_LSHConvertGrid()</a> that converts a <a class="reference external" href="../doxygen/struct_l_s_h___g_r_i_d.html">LSH_GRID</a>
to an equivalent <a class="reference external" href="../doxygen/struct_c_i___l_s_h_m_a_t.html">CI_LSHMAT</a> using the following functions:</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/group___m_c.html#ga3043fd367eac2b3af49343669710955d">MC_LSHComputeMinBitdiff()</a> can be used to compute the minimum number
of bits to use to encode the matrix into the HW format.</li>
<li><a class="reference external" href="../doxygen/group___m_c.html#gaeb725673d8bacacf9b14d9b868c1f1f1">MC_LSHGetSizes()</a> get the stride and line size for a matrix using a
specific bits per diff for the encoding.</li>
</ul>
<p>For testing purposes the MC layer also has <a class="reference external" href="../doxygen/group___m_c.html#ga40ad89dff58ba620f5d643b5e0d96a86">MC_LSHPreCheckTest()</a> that can
be used to ensure that matrices generated using <a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gaae7dddebe8af11ee38ad84b4632d20b0">LSH_FillLinear()</a> or
<a class="reference external" href="../doxygen/group___c_o_m_m_o_n___l_s_h.html#gad0cdb265f45225d7789f521c656ef39b">LSH_FillBowl()</a> are following the maximum gain and correct bits per
difference selected.</p>
<p>An example of usage of the FelixCommon and MC functions could be (simplified
version of felixtest.c used for the driver_test test application):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">IMG_UINT32</span> <span class="n">uiAllocation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">IMG_UINT32</span> <span class="n">matId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">IMG_UINT32</span> <span class="n">uiStride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">IMG_UINT32</span> <span class="n">uiLineSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">IMG_UINT8</span> <span class="n">ui8BitsPerDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">CI_LSHMAT</span> <span class="n">sMatrix</span><span class="p">;</span>
<span class="n">LSH_GRID</span> <span class="n">sGrid</span><span class="p">;</span>
<span class="n">IMG_RESULT</span> <span class="n">ret</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;deshading_t32.lsh&quot;</span><span class="p">;</span>

<span class="c1">// ensure that structure is initialised</span>
<span class="n">IMG_MEMSET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LSH_GRID</span><span class="p">));</span>

<span class="c1">// allocates and populate the LSH_GRID structure from disk</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">LSH_Load_bin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LSH_GRID</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to load &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IMG_ERROR_FATAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ui8BitsPerDiff</span> <span class="o">=</span> <span class="n">MC_LSHComputeMinBitdiff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">LOG_INFO</span><span class="p">(</span><span class="s">&quot;LSH grid %s uses %u bits per difference</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">filename</span><span class="p">,</span> <span class="n">ui8BitsPerDiff</span><span class="p">);</span>

<span class="n">uiAllocation</span> <span class="o">=</span> <span class="n">MC_LSHGetSizes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">,</span> <span class="n">ui8BitsPerDiff</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">uiLineSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStride</span><span class="p">);</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">CI_PipelineAllocateLSHMatrix</span><span class="p">(</span><span class="n">pPipeline</span><span class="p">,</span> <span class="n">uiAllocation</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">matId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to allocate LSH matrix buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">LSH_Free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IMG_ERROR_FATAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// first get the memory</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">CI_PipelineAcquireLSHMatrix</span><span class="p">(</span><span class="n">pPipeline</span><span class="p">,</span> <span class="n">matId</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sMatrix</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to acquire the LSH matrix %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">matId</span><span class="p">);</span>
    <span class="n">LSH_Free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IMG_ERROR_FATAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// then convert the grid to HW format</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">MC_LSHConvertGrid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">,</span> <span class="n">ui8BitsPerDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sMatrix</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to convert the LSH matrix %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">matId</span><span class="p">);</span>
    <span class="n">LSH_Free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IMG_ERROR_FATAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// apply the converted matrix to the device memory</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">CI_PipelineReleaseLSHMatrix</span><span class="p">(</span><span class="n">pPipeline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sMatrix</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to release the LSH matrix %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">matId</span><span class="p">);</span>
    <span class="n">LSH_Free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IMG_ERROR_FATAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// configure the new matrix to be the one the HW uses</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">CI_PipelineUpdateLSHMatrix</span><span class="p">(</span><span class="n">pPipeline</span><span class="p">,</span> <span class="n">matId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to update the LSH matrix %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">matId</span><span class="p">);</span>
    <span class="n">LSH_Free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IMG_ERROR_FATAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// the matrix has been converted - we don&#39;t need the initial object</span>
<span class="n">LSH_Free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sGrid</span><span class="p">);</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="ci_appendix_ioctl.html#isp-ci-ioctl-tables"><span>CI Appendix: IOCTL tables</span></a> contains the details of the user-kernel
communication.</p>
</div>
<div class="section" id="lsh-grid-from-kernel-space">
<span id="isp-ci-lsh-kernel-space"></span><h4>LSH grid from kernel-space<a class="headerlink" href="#lsh-grid-from-kernel-space" title="Permalink to this headline">¶</a></h4>
<p>The handling of the grid in the kernel space is a bit more complex than the
user-space because it has to handle a very strong HW limitation: the LSH module
has <em>not</em> been designed to allow the grid to change every frames.</p>
<p>The HW needs several registers AND load structure elements to be written for a
complete LSH grid to be configured properly. This means that configuring a new
grid can fail if the configuration is different from the currently applied one.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This limitation only applies to a Pipeline object that:</p>
<ul class="simple">
<li>started the capture</li>
<li>has elements in the pending list</li>
</ul>
<p class="last">And applies to <em>any</em> change including configuring the first grid.</p>
</div>
<div class="section" id="lsh-grid-buffer-creation">
<h5>LSH grid: buffer creation<a class="headerlink" href="#lsh-grid-buffer-creation" title="Permalink to this headline">¶</a></h5>
<p>The creation of a buffer for the LSH grid is similar to a normal output buffer.
It uses the same IOCTL and enters the kernel modules in
<a class="reference external" href="../doxygen/group___i_n_t___c_i.html#ga4dbeff49338ef6b18cf23af5b88dfe11">INT_CI_PipelineCreateBuffer()</a>. The creation is delegated to
<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gafa5052a0fd8e8ee00bea9371e80f7221">KRN_CI_PipelineCreateLSHBuffer()</a> which creates a
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___l_s_h___m_a_t_r_i_x.html">KRN_CI_LSH_MATRIX</a> that contains a normal <a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a> used for
the memory. The <a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a> uses a special type
(<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gga6047a5205fb969a75d9dffc21a67148aa99b45de70564c444c7d8fff5a330da5f">CI_BUFF_LSH_IN</a>) to be recognised when mapping to user space.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">LSH buffers cannot be tiled.</p>
</div>
<p>The mapping to user space is handled in a similar way that for any buffer (to
the extent that LSH buffers are accessible for writing). The
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a> is added to the non-mapped list using
<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gafc978c3c4f7ebf485b350388e278f3c2">KRN_CI_PipelineAddBuffer()</a> When <cite>mmap()</cite> is called by user-space it will
trigger <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga30204056cf8cad7bb1e932691a2fe642">KRN_CI_PipelineBufferMapped()</a> which will add it the new matrix
to the <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a1acd81203fabe8b9d76bbc1c4a35a682">KRN_CI_PIPELINE::sList_matrixBuffers</a> instead of
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#afb4dd7e763740f9af8d0bf41f922ed40">KRN_CI_PIPELINE::sList_availableBuffers</a>.</p>
</div>
<div class="section" id="which-matrix-is-currently-in-use">
<h5>Which matrix is currently in use<a class="headerlink" href="#which-matrix-is-currently-in-use" title="Permalink to this headline">¶</a></h5>
<p>The kernel side Pipeline knows which LSH matrix is in use by using the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a6c727223f4df4ccd024e9474b8a1b87f">KRN_CI_PIPELINE::pMatrixUsed</a> pointer which can be NULL.</p>
<p>The currently used matrix is changed using <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gae04d03693dca6801414daf0d0394e494">KRN_CI_PipelineUpdateMatrix()</a>.
This is done when starting the capture (<a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga17928ecb8ed799e31cf6413a663e9d1f">KRN_CI_PipelineStartCapture()</a>
or when updating the matrix in <a class="reference external" href="../doxygen/group___i_n_t___c_i.html#ga502a7e41e22cea289c7c925898d2fbdf">INT_CI_PipelineChangeLSHMatrix()</a></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><a class="reference external" href="../doxygen/group___i_n_t___c_i.html#ga502a7e41e22cea289c7c925898d2fbdf">INT_CI_PipelineChangeLSHMatrix()</a> updates the matrix only if:</p>
<ul class="simple">
<li>the capture is not started or</li>
<li>for a started capture: the Pipeline has no pending buffers or</li>
<li>the configuration for the new matrix is the same than the old one</li>
</ul>
<p class="last">This ensures that if the HW is computing frames only the LSH address can
change.</p>
</div>
<p>The function <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga194befbfcdfa32106dbed3b14e806648">KRN_CI_DriverCheckDeshading()</a> is used to ensure that the
matrix size respects the HW limitation (especially the
<a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html#a18ebb28753a5c4d4eb0e515f21e72a72">CI_HWINFO::ui32LSHRamSizeBits</a>).</p>
</div>
</div>
</div>
<div class="section" id="output-formats-and-sizes">
<span id="isp-ci-output-formats"></span><h3>Output Formats and sizes<a class="headerlink" href="#output-formats-and-sizes" title="Permalink to this headline">¶</a></h3>
<p>This section describes how to choose the output format using the registers
values and the MC/CI setup associated with these formats.
More advanced output formats may be possible using the high level setup
parameters to configure the ISPC library. (see <a class="reference internal" href="../ispc/ispc_modules.html#isp-ispc-out"><span>Output formats (OUT)</span></a>).</p>
<p>The last part of this section explains how the buffer sizes are computed
and how the user can allocate or import different sizes. It also explains
how to trigger frames to be captured with different memory layout.</p>
<div class="section" id="encoder-pipeline-formats-yuv">
<span id="isp-ci-encoder-output"></span><h4>Encoder pipeline formats (YUV)<a class="headerlink" href="#encoder-pipeline-formats-yuv" title="Permalink to this headline">¶</a></h4>
<p>The encoder pipeline (after ESC block) can produce 4 YUV formats (see <em>TRM</em>
for more details):</p>
<ul class="simple">
<li>NV21 8 bits (420PL12YVU8) and its 10 bits equivalent</li>
<li>NV61 8 bits (422PL12YVU8) and its 10 bits equivalents</li>
</ul>
<p>The size used by default for allocation is using the sensor&#8217;s size from the
IIF configuration but can be changed using
<span>CI_PIPELINE::ui16MaxEncOutWidth</span> and
<span>CI_PIPELINE::ui16MaxEncOutHeight</span>. These variables are updated if the
capture is not started and no image buffers were allocated yet.</p>
<div class="section" id="register-setup">
<h5>Register setup<a class="headerlink" href="#register-setup" title="Permalink to this headline">¶</a></h5>
<p>The control of the output format is done using a few registers:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">SAVE_CONFIG_FLAGS</span></code>:<ul>
<li><code class="docutils literal"><span class="pre">ENC_FORMAT</span></code> to select the bit-depth (0 for 8 bits, 1 for 10 bits).</li>
<li><code class="docutils literal"><span class="pre">ENC_ENABLE</span></code> should be 1 (enabled).</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">ENC_SCAL_V_SETUP::422_NOT_420</span></code></li>
<li><code class="docutils literal"><span class="pre">ENC_422_TO_420_CTRL::ENC_422_TO_420_ENABLE</span></code> is a legacy register and
should always be 0.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="21%" />
<col width="23%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head"><code class="docutils literal"><span class="pre">ENC_FORMAT</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">422_NOT_420</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">ENC_422_TO_420_ENABLE</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>NV21</td>
<td><p class="first">0 for 8b</p>
<p class="last">1 for 10b</p>
</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>NV61</td>
<td><p class="first">0 for 8b</p>
<p class="last">1 for 10b</p>
</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When subsampling to 420 using the scaler the Vertical Chroma taps should
be computed as if the vertical pitch was doubled.</p>
</div>
</div>
<div class="section" id="ci-setup">
<h5>CI setup<a class="headerlink" href="#ci-setup" title="Permalink to this headline">¶</a></h5>
<p>To enable YUV output <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> should be modified with:</p>
<ul>
<li><p class="first"><span>eEncType</span> should have the correct YUV format
that can be setup using the <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#ga6af1827825420938a912c43f7ec4b5e9">PixelTransformYUV()</a> function with the
correct <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#gac0cdaadb402d65eb1ac8a1d78cc9553b">ePxlFormat</a> value:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">YUV_420_PL12_8</span></code></li>
<li><code class="docutils literal"><span class="pre">YUV_422_PL12_8</span></code></li>
<li><code class="docutils literal"><span class="pre">YUV_420_PL12_10</span></code></li>
<li>or <code class="docutils literal"><span class="pre">YUV_422_PL12_10</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><span>ui16MaxEncOutWidth</span> and
<span>ui16MaxEncOutHeight</span> should be the
imager size after decimation (or the output will need cropping).</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/struct_c_i___m_o_d_u_l_e___s_c_a_l_e_r.html#a395427b2107e0bb643e8dcd77c611b95">CI_MODULE_SCALER::bOutput422</a> should be configured correctly according
to the selected output in <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html#aa062efddfde663d8ddad4502c37ec719">CI_PIPELINE::sEncoderScaler</a>.</p>
</li>
</ul>
</div>
<div class="section" id="mc-setup">
<h5>MC setup<a class="headerlink" href="#mc-setup" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#gac0cdaadb402d65eb1ac8a1d78cc9553b">ePxlFormat</a> enum is stored in <a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html#a004f7e82b4ea78edd96d1eec425cb460">MC_PIPELINE::eEncOutput</a> and
the size is derived from the IIF setup. To change the maximum size ensure it
is over-written after the conversion is done.</p>
<p>E.g. in <code class="docutils literal"><span class="pre">mc_convert.c</span></code>:</p>
<div class="highlight-C"><div class="highlight"><pre><span class="n">PixelTransformYUV</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">eEncType</span><span class="p">),</span> <span class="n">pMCPipeline</span><span class="o">-&gt;</span><span class="n">eEncOutput</span><span class="p">);</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">ui16MaxEncOutWidth</span> <span class="o">=</span> <span class="n">pMCPipeline</span><span class="o">-&gt;</span><span class="n">sIIF</span><span class="p">.</span><span class="n">ui16ImagerSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">CI_CFA_WIDTH</span><span class="p">;</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">ui16MaxEncOutHeight</span> <span class="o">=</span> <span class="n">pMCPipeline</span><span class="o">-&gt;</span><span class="n">sIIF</span><span class="p">.</span><span class="n">ui16ImagerSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">CI_CFA_HEIGHT</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">sEncoderScaler</span><span class="p">.</span><span class="n">bOutput422</span> <span class="o">=</span>
    <span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">eEncType</span><span class="p">.</span><span class="n">ui8HSubsampling</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="nl">IMG_TRUE</span> <span class="p">:</span> <span class="n">IMG_FALSE</span><span class="p">;</span>  <span class="c1">// 422</span>
</pre></div>
</div>
</div>
<div class="section" id="enabling-tiling">
<h5>Enabling Tiling<a class="headerlink" href="#enabling-tiling" title="Permalink to this headline">¶</a></h5>
<blockquote>
<div><p>The YUV output can be enabled as tiled. In that case the fields
<code class="docutils literal"><span class="pre">ENC_L_TILE_EN</span></code> and <code class="docutils literal"><span class="pre">ENC_C_TILE_EN</span></code> in the <code class="docutils literal"><span class="pre">TILING_CONTROL</span></code>
register of the linked list should be updated.</p>
<p>When allocating the buffer with CI the tiling option will change the
output size and the result buffer from the HW will need de-tiling to
be displayable.</p>
</div></blockquote>
</div>
<div class="section" id="additional-yuv-formats">
<h5>Additional YUV formats<a class="headerlink" href="#additional-yuv-formats" title="Permalink to this headline">¶</a></h5>
<p>It is possible to configure the HW such that the chroma component order
could be different (HW outputs VU order as NV21 supports). Modifying the
values for the R2Y block and any subsequent block affected by the Chroma
order would allow the output of NV12 (MIE, R2Y). It is possible that R2Y may
not be affected if similar options are available for RGB ordering (output of
BGR instead of standard RGB, see <a class="reference internal" href="#isp-ci-display-output"><span>Display pipeline formats (RGB)</span></a>).</p>
<p>This configuration tricks should however be avoided at the CI level as the
High level libraries provide an easier way to support such formats.</p>
</div>
</div>
<div class="section" id="display-pipeline-formats-rgb">
<span id="isp-ci-display-output"></span><h4>Display pipeline formats (RGB)<a class="headerlink" href="#display-pipeline-formats-rgb" title="Permalink to this headline">¶</a></h4>
<p>The display pipeline (after DSC block) can produce 3 RGB formats:</p>
<ul class="simple">
<li>RGB8 24b (3 channels, 8b per channel).</li>
<li>RGB8 32b (3 channels, 8b per channel packed in the LSB of 32b) – similar
to RGBA without alpha channel.</li>
<li>RGB10 32b (3 channels, 10b per channel packed in the LSB of 32b).</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is not possible to have data extraction and RGB output enabled at the
same time (HW design).</p>
</div>
<p>The size used by default for allocation is using the sensor&#8217;s size from the
IIF configuration but can be changed using
<span>CI_PIPELINE::ui16MaxDispOutWidth</span> and
<span>CI_PIPELINE::ui16MaxDispOutHeight</span>. These variables are updated if the
capture is not started and no image buffers were allocated yet.</p>
<div class="section" id="id2">
<h5>Register setup<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>To enable RGB output 3 fields have to be setup in the <code class="docutils literal"><span class="pre">SAVE_CONFIG_FLAGS</span></code>
register:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">DISP_DE_ENABLE</span></code> should be 1 (enabled)</li>
<li><code class="docutils literal"><span class="pre">DE_NO_DISP</span></code> should be written to 0 (enable display pipeline rather than
data extraction)</li>
<li><code class="docutils literal"><span class="pre">DISP_DE_FORMAT</span></code> should have the correct value</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="31%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head"><code class="docutils literal"><span class="pre">DE_NO_DISP</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">DISP_DE_FORMAT</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RGB8 24b</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>RGB8 32b</td>
<td>0</td>
<td>3</td>
</tr>
<tr class="row-even"><td>RGB10 32b</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id3">
<h5>CI setup<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>To enable RGB output <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> should be modified with:</p>
<ul>
<li><p class="first"><span>eDispType</span> should have the correct RGB
format that can be setup using the <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#gacaa902589aa089578248eaab09852b23">PixelTransformRGB()</a> function with
the correct <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#gac0cdaadb402d65eb1ac8a1d78cc9553b">ePxlFormat</a> value:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">RGB_888_24</span></code></li>
<li><code class="docutils literal"><span class="pre">RGB_888_32</span></code></li>
<li><code class="docutils literal"><span class="pre">RGB_101010_32</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><span>ui16MaxDispOutWidth</span> and
<span>ui16MaxDispOutHeight</span> should be the
imager size after decimation (or the output will need cropping).</p>
</li>
</ul>
</div>
<div class="section" id="id4">
<h5>MC setup<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#gac0cdaadb402d65eb1ac8a1d78cc9553b">ePxlFormat</a> enum is the one stored in
<a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html#a085f8d6e8e5dafc2cd041ea826839a6d">MC_PIPELINE::eDispOutput</a>. The size is derived from the IIF setup.</p>
<p>E.g. (from <code class="docutils literal"><span class="pre">mc_convert.c</span></code>)</p>
<div class="highlight-C"><div class="highlight"><pre><span class="n">PixelTransformRGB</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">eDispType</span><span class="p">),</span> <span class="n">pMCPipeline</span><span class="o">-&gt;</span><span class="n">eDispOutput</span><span class="p">);</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">ui16MaxDispOutWidth</span> <span class="o">=</span> <span class="n">pMCPipeline</span><span class="o">-&gt;</span><span class="n">sIIF</span><span class="p">.</span><span class="n">ui16ImagerSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">CI_CFA_WIDTH</span><span class="p">;</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">ui16MaxDispOutHeight</span> <span class="o">=</span> <span class="n">pMCPipeline</span><span class="o">-&gt;</span><span class="n">sIIF</span><span class="p">.</span><span class="n">ui16ImagerSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">CI_CFA_HEIGHT</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>Enabling Tiling<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>The RGB output can be enabled as tiled. In that case the field
<code class="docutils literal"><span class="pre">DISP_DE_TILE_EN</span></code> in the <code class="docutils literal"><span class="pre">TILING_CONTROL</span></code> register of the linked
list should be updated.</p>
</div>
<div class="section" id="additional-rgb-formats">
<h5>Additional RGB formats<a class="headerlink" href="#additional-rgb-formats" title="Permalink to this headline">¶</a></h5>
<p>It is possible to configure the HW modules to output RGB formats with
different components orders. The V2500 HW outputs standard RGB (B in LSB)
but by swapping the Y2R matrix it is possible to configure the HW to output
BGR (R in LSB). Note that this may affect other modules as well (DGM needs
some of its register values to be swapped as well).</p>
<p>As for the YUV swapping this configuration tricks should however be avoided at
the CI level as the High level libraries provide an easier way to support
such formats.</p>
</div>
</div>
<div class="section" id="data-extraction-formats-bayer">
<span id="isp-ci-data-extraction-output"></span><h4>Data Extraction formats (Bayer)<a class="headerlink" href="#data-extraction-formats-bayer" title="Permalink to this headline">¶</a></h4>
<p>The V2500 hardware has several data extraction points where the image can be
retrieved before further corrections are applied to it. The <em>TRM</em> should
detail them. The point of extraction is global between contexts and for the
moment only supports Bayer format (it is at the beginning of the HW
pipeline). Bayer format with 8b, 10b or 12b RGGB patterns are available.</p>
<p>The size used by default for allocation is using the sensor&#8217;s size from the
IIF configuration</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is not possible to have data extraction and RGB output enabled at the
same time (HW design).</p>
</div>
<div class="section" id="id6">
<h5>Register setup<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>To enable DE output 3 fields have to be setup in the <code class="docutils literal"><span class="pre">SAVE_CONFIG_FLAGS</span></code>
register:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">DISP_DE_ENABLE</span></code> should be 1 (enabled)</li>
<li><code class="docutils literal"><span class="pre">DE_NO_DISP</span></code> should be written to 1 (enable data extraction instead of
display pipeline)</li>
<li><code class="docutils literal"><span class="pre">DISP_DE_FORMAT</span></code> should have the correct value</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="31%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head"><code class="docutils literal"><span class="pre">DE_NO_DISP</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">DISP_DE_FORMAT</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RGGB 8b</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>RGGB 10b</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>RGGB 12b</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id7">
<h5>CI setup<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>The CI setup to enable Data Extraction is slightly more complicated,
<a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> should be modified with:</p>
<ul class="simple">
<li><span>eDispType</span> should have the correct Bayer
format for the selected DE point.</li>
<li><span>ui16MaxDispOutWidth</span> and
<span>ui16MaxDispOutHeight</span> should be the
imager size after decimation (or the output will need cropping).</li>
<li><span>eDataExtraction</span> should be the DE
point in the Pipeline</li>
</ul>
<p>E.g.</p>
<div class="highlight-C"><div class="highlight"><pre><span class="n">PixelTransformBayer</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">eDispType</span><span class="p">),</span> <span class="n">BAYER_RGGB_10</span><span class="p">,</span> <span class="n">MOSAIC_RGGB</span><span class="p">);</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">ui16MaxDispOutWidth</span> <span class="o">=</span> <span class="n">ui16ImagerSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">CI_CFA_WIDTH</span><span class="p">;</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">ui16MaxDispOutHeight</span> <span class="o">=</span> <span class="n">ui16ImagerSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">CI_CFA_HEIGHT</span><span class="p">;</span>
<span class="n">pCIPipeline</span><span class="o">-&gt;</span><span class="n">eDataExtraction</span> <span class="o">=</span> <span class="n">eSelectedDEPoint</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h5>MC setup<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>To setup the MC layer with Data Extraction enabled a few parameters of the
<a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html">MC_PIPELINE</a> should be modified:</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html#af97f04228e7ac76cd8e4940212b01b28">eDEPoint</a> should be set to the wanted DE point</li>
<li><a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html#a085f8d6e8e5dafc2cd041ea826839a6d">eDispOutput</a> should be disabled
(<code class="docutils literal"><span class="pre">PXL_NONE</span></code>)</li>
<li>the maximum size is computed using the IIF setup</li>
</ul>
<p>E.g.</p>
<div class="highlight-C"><div class="highlight"><pre><span class="n">sMCPipelineConfig</span><span class="p">.</span><span class="n">eDispOutput</span> <span class="o">=</span> <span class="n">PXL_NONE</span><span class="p">;</span>
<span class="n">sMCPipelineConfig</span><span class="p">.</span><span class="n">eDEPoint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h5>Enabling Tiling<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>Enabling Bayer tiling is possible using the same mechanism than the
Display output for the HW. But the driver does not allow tiling of the
data-extraction buffer.</p>
</div>
</div>
<div class="section" id="hdr-extraction">
<span id="isp-ci-hdr-output"></span><h4>HDR Extraction<a class="headerlink" href="#hdr-extraction" title="Permalink to this headline">¶</a></h4>
<p>HDR Extraction is a special point in the pipeline where RGB image can be
extracted at a higher bit-depth than display output. The images are then
intended to be merged by an algorithm and inserted back in the HDR
insertion point.</p>
<p>The V2500 HW allows extraction of a high bit-depth RGB format that can be
used by Imagination&#8217;s GPU to perform HDR processing over several frames. The
extraction is done in between the Main Gamut Mapper and the Gamma LUT blocks
in the HW. A single format is supported by the HW that is very similar to
RGB32 10b. The intended usage is to extract a few frames using HDR
Extraction and push them back into the pipeline after the GPU merged them
using the HDR Insertion.</p>
<p>The size used by default for allocation is using the sensor&#8217;s size from the
IIF configuration</p>
<div class="section" id="id10">
<h5>Register setup<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>To enable HDR Extraction (called HDF in registers) 2 fields have to be set
into the <code class="docutils literal"><span class="pre">SAVE_CONFIG_FLAGS</span></code> register:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HDF_WR_ENABLE</span></code> should be 1</li>
<li><code class="docutils literal"><span class="pre">HDF_WR_FORMAT</span></code> should be the relevant format</li>
</ul>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head"><code class="docutils literal"><span class="pre">HDF_WR_FORMAT</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>BGR10 32b</td>
<td>1</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="id11">
<h5>CI setup<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>To enable the HDR Extraction the <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> should be modified with:</p>
<ul class="simple">
<li><span>eHDRExtType</span> should be the correct format
(<code class="docutils literal"><span class="pre">BGR_101010_32</span></code> transformed with <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#gacaa902589aa089578248eaab09852b23">PixelTransformRGB()</a>).</li>
<li>The size of the allocated buffer should be whole image processed by the
IIF (when allocating the buffer with CI it is computed using the IIF
register values).</li>
</ul>
</div>
<div class="section" id="id12">
<h5>MC setup<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>To enable the HDR Extraction the <a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html#a03eb637c97e7486cea05f7417f588766">MC_PIPELINE::eHDRExtOutput</a> should
have the correct enum value (<code class="docutils literal"><span class="pre">BGR_101010_32</span></code>). The size limitations are
the same than in CI.</p>
</div>
<div class="section" id="id13">
<h5>Enabling Tiling<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>The HDR Extraction output can be tiled and the <code class="docutils literal"><span class="pre">HDF_WE_TILE_EN</span></code> field
of the <code class="docutils literal"><span class="pre">TILING_CONTROL</span></code> register should be updated accordingly.</p>
</div>
</div>
<div class="section" id="raw-2d-extraction-tiff">
<span id="isp-ci-raw2d-output"></span><h4>Raw 2D Extraction (TIFF)<a class="headerlink" href="#raw-2d-extraction-tiff" title="Permalink to this headline">¶</a></h4>
<p>The Raw 2D extraction is a special point in the pipeline that allow to
extract specially formatted Bayer images just before the demosaicer.</p>
<p>Because the format is Byte aligned in memory (not using
the alignment other output buffers use) it cannot be tiled (HW design).
The HW supports 2 formats: 10b and 12b TIFF.</p>
<p>The size used by default for allocation is using the sensor&#8217;s size from the
IIF configuration</p>
<div class="section" id="id14">
<h5>Register setup<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
<p>To enable Raw 2D Extraction 2 fields of the <code class="docutils literal"><span class="pre">SAVE_CONFIG_FLAGS</span></code>
register have to be setup:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">RAW_2D_ENABLE</span></code> set to 1</li>
<li><code class="docutils literal"><span class="pre">RAW_2D_FORMAT</span></code> set to the correct value.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head"><code class="docutils literal"><span class="pre">RAW_2D_FORMAT</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>TIFF 10b</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>TIFF 12b</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id15">
<h5>CI setup<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> element that should be modified to enable RAW2D
extraction are:</p>
<ul class="simple">
<li><span>eRaw2DExtraction</span> derived from a TIFF
format using <a class="reference external" href="../doxygen/group___f_e_l_i_x___c_o_m_m_o_n.html#ga26dc50c76560e29367d28ef8cb4ba616">PixelTransformBayer()</a>.</li>
<li>The size of the allocated buffer should be whole image processed by the
IIF (when allocating the buffer with CI it is computed using the IIF
register values).</li>
</ul>
</div>
<div class="section" id="id16">
<h5>MC setup<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p>To enable RAW 2D extraction the <a class="reference external" href="../doxygen/struct_m_c___p_i_p_e_l_i_n_e.html#a8de75e331510c1390b875479e50ade30">MC_PIPELINE::eRaw2DExtOutput</a> enum
should be modified to be either <code class="docutils literal"><span class="pre">BAYER_TIFF_10</span></code> or
<code class="docutils literal"><span class="pre">BAYER_TIFF_12</span></code>. The same size limitations apply than in CI.</p>
</div>
<div class="section" id="id17">
<h5>Enabling Tiling<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Tiling cannot be enabled for RAW 2D output (HW design).</p>
</div>
</div>
</div>
<div class="section" id="different-output-size">
<span id="isp-ci-output-size"></span><h4>Different Output Size<a class="headerlink" href="#different-output-size" title="Permalink to this headline">¶</a></h4>
<p>The user-space library provides several way to allocate output buffers, both
are using <a class="reference external" href="../doxygen/ci__api_8h.html#a51a5289974c9ea89dae9362ce3403748">CI_PipelineAllocateBuffer()</a>:</p>
<ul class="simple">
<li>give a size of 0 and let the kernel-space compute the correct output size</li>
<li>give a defined size for the output.</li>
</ul>
<p>The kernel-space <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga8677d13fa3955e8371f46ad4e308f310">KRN_CI_PipelineCreateBuffer()</a> will verify the size of
the buffer using <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gaec970a03d2dbfcab1a813eda2c7ecf15">KRN_CI_BufferFromConfig()</a>. This function delegates the
size computation to several functions that are part of the FelixCommon library:</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/group___c_i___a_l_l_o_c.html#gaeff0899305c689f034fe0e7d33d54763">CI_ALLOC_RGBSizeInfo()</a> to compute RGB output sizes (HDR input and output are also RGB)</li>
<li><a class="reference external" href="../doxygen/group___c_i___a_l_l_o_c.html#gaeff0899305c689f034fe0e7d33d54763">CI_ALLOC_RGBSizeInfo()</a> is also used to compute Bayer sizes.</li>
<li><a class="reference external" href="../doxygen/group___c_i___a_l_l_o_c.html#ga9e50c50c1d21771a528707b63478cd09">CI_ALLOC_Raw2DSizeInfo()</a> to compute Bayer TIFF sizes as the format is packed.</li>
<li><a class="reference external" href="../doxygen/group___c_i___a_l_l_o_c.html#ga1c618117534c3b6300740922c236c840">CI_ALLOC_YUVSizeInfo()</a> is used to compute the YUV output sizes.</li>
<li>All of the above use <a class="reference external" href="../doxygen/group___c_i___a_l_l_o_c.html#ga2f50b29557b7799eaf6f8881f9b3760e">CI_ALLOC_GetTileInfo()</a> to get tiling information.</li>
</ul>
<p>If the provided size is 0 then the size from <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gaec970a03d2dbfcab1a813eda2c7ecf15">KRN_CI_BufferFromConfig()</a>
will be used. Otherwise the size will be checked to be big enough.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The maximum output sizes are the sizes used for the Encoder and Display
output. It is important that those sizes are correct when allocating
buffers.</p>
<p class="last">The images before the scaler (Bayer or HDR) are using the size configured
in the IIF block.</p>
</div>
<p>The <a class="reference external" href="../doxygen/ci__api_8h.html#a51a5289974c9ea89dae9362ce3403748">CI_PipelineAllocateBuffer()</a> also returns an optional buffer
identifier. This identifier is very important if using several sizes of
buffers.</p>
<p>The default memory layout assumed by <a class="reference external" href="../doxygen/ci__api_8h.html#a51a5289974c9ea89dae9362ce3403748">CI_PipelineAllocateBuffer()</a> does
not include special offsets between planes. It is quite common that the consumer
of a buffer will require some special output sizes or offset to be respected.
The size given to the allocation function should reflect that. However the
actual offset of each plane is provided for each enqueued frame.</p>
<p>More information about how each format size is computed is available in
<a class="reference internal" href="ci_appendix_alloc.html#isp-ci-frame-size-computation"><span>CI Appendix: Frame Size Computation</span></a>.</p>
</div>
<div class="section" id="different-memory-layout">
<span id="isp-ci-output-layout"></span><h4>Different memory layout<a class="headerlink" href="#different-memory-layout" title="Permalink to this headline">¶</a></h4>
<p>The memory layout is specified when triggering frames. The user has a choice:</p>
<ul class="simple">
<li>trigger the first available buffer from the list with default memory layout.</li>
<li>trigger specific frame with a changed memory layout.</li>
</ul>
<p>The first solution is covered by using <a class="reference external" href="../doxygen/ci__api_8h.html#a7184dc54c0f349c2b906a2cb0e72e09e">CI_PipelineTriggerShoot()</a> or
<a class="reference external" href="../doxygen/ci__pipeline_8c.html#ae4d1484fdc1fc4b035f973b7097a882e">CI_PipelineTriggerShootNB()</a> and is triggering captures with planes
usually back to back.</p>
<p>The second solution is using <a class="reference external" href="../doxygen/ci__pipeline_8c.html#abe5934c3cb1f092ea8b9c99feecef176">CI_PipelineTriggerSpecifiedShoot()</a> or
<a class="reference external" href="../doxygen/ci__pipeline_8c.html#a7d581fd0f9ef85560857865ffab68a3d">CI_PipelineTriggerSpecifiedShootNB()</a> and requires a <a class="reference external" href="../doxygen/struct_c_i___b_u_f_f_i_d.html">CI_BUFFID</a>
structure to be populated. This structure will contain a buffer identifier,
stride and offset for all planes of all desired outputs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the identifier given for a particular buffer is 0 it will also use the
first available buffer but use a changed memory layout.</p>
</div>
<p>For example, at time of writing, the structure CI_BUFFID is contains the
following fields for the YUV output:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">CI_BUFFID</span>
<span class="p">{</span>
    <span class="cm">/** @brief Encoder buffer Identifier */</span>
    <span class="n">IMG_UINT32</span> <span class="n">encId</span><span class="p">;</span>
    <span class="cm">/**</span>
<span class="cm">     * @brief Encoder Y buffer stride in bytes - if 0 ignored</span>
<span class="cm">     *</span>
<span class="cm">     * @note Needs to be a multiplie of SYSMEM_ALIGNMENT</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT32</span> <span class="n">encStrideY</span><span class="p">;</span>
    <span class="cm">/**</span>
<span class="cm">     * @brief Encoder CbCr buffer stride in bytes - if 0 ignored</span>
<span class="cm">     *</span>
<span class="cm">     * @note Needs to be a multiplie of SYSMEM_ALIGNMENT</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT32</span> <span class="n">encStrideC</span><span class="p">;</span>
    <span class="cm">/**</span>
<span class="cm">     * @brief start of luma plane offset in bytes</span>
<span class="cm">     *</span>
<span class="cm">     * @note Needs to be a multiplie of SYSMEM_ALIGNMENT</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT32</span> <span class="n">encOffsetY</span><span class="p">;</span>
    <span class="cm">/**</span>
<span class="cm">     * @brief chroma offset in bytes - if 0 computed by kernel-side to be</span>
<span class="cm">     * just after luma plane</span>
<span class="cm">     *</span>
<span class="cm">     * @note Needs to be a multiplie of SYSMEM_ALIGNMENT</span>
<span class="cm">     */</span>
    <span class="n">IMG_UINT32</span> <span class="n">encOffsetC</span><span class="p">;</span>

    <span class="cm">/* ... */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Using the exmaple computation from <a class="reference internal" href="ci_appendix_alloc.html#isp-ci-frame-example-2frames"><span>2 Frames
example</span></a> we can therefore use the buffer as
following (see <a class="reference internal" href="../ispc/ispc_library.html#isp-ispc-output-layout"><span>Populating a specific Buffer when enqueuing shots</span></a> for ISPC equivalent):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1567808</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1088</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a_off_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a_off_cbcr</span> <span class="o">=</span> <span class="mi">783360</span><span class="p">,</span>
    <span class="n">b_off_y</span> <span class="o">=</span> <span class="mi">1088</span><span class="p">,</span> <span class="n">b_off_cbcr</span> <span class="o">=</span> <span class="mi">784448</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * assumes pPipeline is connected, configured but not started yet</span>
<span class="cm"> * the call could also be to CI_PipelineImportBuffer()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">buffId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">CI_PipelineAllocateBuffer</span><span class="p">(</span><span class="n">pPipeline</span><span class="p">,</span> <span class="n">CI_TYPE_ENCODER</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
    <span class="n">IMG_FALSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffId</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * the capture should now be started so that we can configure the</span>
<span class="cm"> * trigger of a frame buffId could be found from a list after</span>
<span class="cm"> * allocation or left to 0 and let the 1st available buffer be used</span>
<span class="cm"> * (in that case the assumption is that all the YUV buffers were</span>
<span class="cm"> * allocated with the correct size</span>
<span class="cm"> */</span>

 <span class="n">CI_BUFFID</span> <span class="n">toTrigger</span><span class="p">;</span>
 <span class="c1">// memset to ensure other fields are disabled</span>
 <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">toTrigger</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CI_BUFFID</span><span class="p">));</span>

 <span class="n">toTrigger</span><span class="p">.</span><span class="n">encId</span> <span class="o">=</span> <span class="n">buffId</span><span class="p">;</span>
 <span class="n">toTrigger</span><span class="p">.</span><span class="n">encStrideY</span> <span class="o">=</span> <span class="n">stride</span><span class="p">;</span>
 <span class="n">toTrigger</span><span class="p">.</span><span class="n">encStrideC</span> <span class="o">=</span> <span class="n">stride</span><span class="p">;</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">is_a</span><span class="p">)</span>
 <span class="p">{</span>
    <span class="n">toTrigger</span><span class="p">.</span><span class="n">encOffsetY</span> <span class="o">=</span> <span class="n">a_off_y</span><span class="p">;</span>
    <span class="n">toTrigger</span><span class="p">.</span><span class="n">encOffsetC</span> <span class="o">=</span> <span class="n">a_off_cbcr</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span>
    <span class="n">toTrigger</span><span class="p">.</span><span class="n">encOffsetY</span> <span class="o">=</span> <span class="n">b_off_y</span><span class="p">;</span>
    <span class="n">toTrigger</span><span class="p">.</span><span class="n">encOffsetC</span> <span class="o">=</span> <span class="n">b_off_cbcr</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="n">ret</span> <span class="o">=</span> <span class="n">CI_PipelineTriggerSpecifiedShoot</span><span class="p">(</span><span class="n">pPipeline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">toTrigger</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="notes-on-tiling">
<span id="isp-ci-notes-on-tiling"></span><h4>Notes on Tiling<a class="headerlink" href="#notes-on-tiling" title="Permalink to this headline">¶</a></h4>
<p>Tiling is supported as part of the IMG MMU IP. The V2500 chip has
been modified slightly to enable better pre-fetching when tiling is
enabled. The intended usage of tiling is to tile output buffers that
will be used by the GPU, that will de-tile them at the same time
processing is done on the buffer.</p>
<p>Please refer to the <em>Video Bus4 MMU Functional Specification</em> HW
documentation for more details on tiling.</p>
<p>Obviously when allocating the buffer with CI the tiling option will
change the output size and the result buffer from the HW will need
de-tiling to be usable as normal outputs.</p>
<p>To enable tiling output support the user is expected to enable tiling
with <span>CI_PIPELINE::bSupportTiling</span> and also allocate tiled buffers
with <a class="reference external" href="../doxygen/ci__api_8h.html#a51a5289974c9ea89dae9362ce3403748">CI_PipelineAllocateBuffer()</a>. The CI driver will figure out
if a buffer is tiled or not and configure the stride accordingly. See the
<a class="reference internal" href="#isp-ci-tiling-information"><span>MMU Tiling information</span></a> section for details on the SW limitations.</p>
<p>The shared tiling stride is computed in <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga553524d3c54fe26dc606db95a54b948d">KRN_CI_PipelineInit()</a>. The CI
library does not let the user-side compute the size of tiled buffers, it relies
on <a class="reference external" href="../doxygen/ci__alloc__info_8h.html">ci_alloc_info.h</a> to provide the correct sizes for all outputs. Because
each buffers could be triggered as tiled when the
<span>CI_PIPELINE::bSupportTiling</span> is ON then all outputs that can be tiled
will be used to compute the shared tiled stride. This tiled stride can be
changed at insmod time (but if given parameter is too small for allocation then
the setup of the Pipeline will fail) as explained in
<a class="reference internal" href="../getting_started.html#isp-gsg-insmod-options"><span>V2500 Insertion options</span></a>.</p>
</div>
</div>
<div class="section" id="v2500-cache-behaviour">
<span id="isp-ci-v2500-cache-behaviour"></span><h3>V2500 Cache behaviour<a class="headerlink" href="#v2500-cache-behaviour" title="Permalink to this headline">¶</a></h3>
<p>The Felix HW is connected to a memory interface (E.g. AXI on arm architectures)
that has to control the way the memory is read/written. The cache policy
controls the behaviour of several HW blocks and is always the same:</p>
<ul class="simple">
<li>Bypass the cache</li>
<li>Or write through (direct write to cache and memory)</li>
<li>Or write combine (write to the cache and flush memory later)</li>
</ul>
<p>Additionally some blocks have a configurable &#8220;fence&#8221; behaviour, which is
usually done at the end of writing.</p>
<div class="section" id="compilation-choice">
<span id="isp-ci-cache-compilation-choice"></span><h4>Compilation choice<a class="headerlink" href="#compilation-choice" title="Permalink to this headline">¶</a></h4>
<p>The driver can be changed so that other options than the defaults are used.
The available values for the cache related registers are available in
<a class="reference external" href="../doxygen/felix__hw__info_8h.html">felix_hw_info.h</a> and can be changed by the customer. But it is the
customer&#8217;s responsibility to insure that the caches are dealt with correctly
according to the system they integrate with. The current values are
generated from the defaults stored in our register definitions.</p>
<p>The cache policies are written when accessing the registers in
<code class="docutils literal"><span class="pre">kernel_src/ci_hwstruct.c</span></code>.</p>
<p>Example of cache policy:</p>
<div class="highlight-C"><div class="highlight"><pre><span class="cp">#define USE_WBS_CACHE_POLICY (0) </span><span class="c1">///&lt; @brief Value for WBS_MISC:WBS_CACHE_POLICY</span>
</pre></div>
</div>
<p>Example of writing a cache policy:</p>
<div class="highlight-C"><div class="highlight"><pre><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">REGIO_WRITE_FIELD</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">FELIX_LOAD_STRUCTURE</span><span class="p">,</span> <span class="n">WBS_MISC</span><span class="p">,</span> <span class="n">WBS_ROI_ACT</span><span class="p">,</span>
    <span class="n">pWhiteBalance</span><span class="o">-&gt;</span><span class="n">ui8ActiveROI</span><span class="p">);</span>
<span class="n">REGIO_WRITE_FIELD</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">FELIX_LOAD_STRUCTURE</span><span class="p">,</span> <span class="n">WBS_MISC</span><span class="p">,</span> <span class="n">WBS_CACHE_POLICY</span><span class="p">,</span>
    <span class="n">USE_WBS_CACHE_POLICY</span><span class="p">);</span>
<span class="n">REGIO_WRITE_FIELD</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">FELIX_LOAD_STRUCTURE</span><span class="p">,</span> <span class="n">WBS_MISC</span><span class="p">,</span> <span class="n">WBS_RGB_OFFSET</span><span class="p">,</span>
    <span class="n">pWhiteBalance</span><span class="o">-&gt;</span><span class="n">ui16RGBOffset</span><span class="p">);</span>
<span class="n">REGIO_WRITE_FIELD</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">FELIX_LOAD_STRUCTURE</span><span class="p">,</span> <span class="n">WBS_MISC</span><span class="p">,</span> <span class="n">WBS_Y_OFFSET</span><span class="p">,</span>
    <span class="n">pWhiteBalance</span><span class="o">-&gt;</span><span class="n">ui16YOffset</span><span class="p">);</span>
<span class="n">WriteMem</span><span class="p">((</span><span class="n">IMG_UINT32</span><span class="o">*</span><span class="p">)</span><span class="n">pMemory</span><span class="p">,</span> <span class="n">FELIX_LOAD_STRUCTURE_WBS_MISC_OFFSET</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="suspend-and-resume-calls">
<span id="isp-ci-suspend-and-resume"></span><h3>Suspend and Resume calls<a class="headerlink" href="#suspend-and-resume-calls" title="Permalink to this headline">¶</a></h3>
<p>The <em>suspend</em> and <em>resume</em> calls can be made from the Linux OS to the
drivers to inform that the system is going to a halt. The expected behaviour
is to save the current &#8220;HW context&#8221; (as registers are lost when resume is
called) and restart to work when resume is triggered. Suspension is
transparent to user-side and it is assumed that user-side is already frozen
when suspend is called.</p>
<p>The driver does not expect a capture to be &#8220;resumable&#8221;, as the time of
suspension is unknown it is hard to relate with previously captured
statistics and images. Therefore when suspend is called the driver stops all
running captures and turns the HW off.</p>
<p>When the <em>resume</em> action is called the HW is restarted and user-space has to
resynchronise its &#8220;started&#8221; status (when <a class="reference external" href="../doxygen/img__errors_8h.html#acd2f5e620c6542d93c88f63d10a3ae2f">IMG_ERROR_UNEXPECTED_STATE</a> is
received). Once that is done the application can choose to restart the
capture or not.</p>
</div>
</div>
<div class="section" id="user-kernel-interactions">
<span id="isp-ci-user-kernel-interactions"></span><h2>User/Kernel interactions<a class="headerlink" href="#user-kernel-interactions" title="Permalink to this headline">¶</a></h2>
<p>The driver is designed to use IOCTL to communicate information from
user-side to kernel-side. This is fairly standard for a Linux driver.</p>
<p>Read and write operations are not supported.</p>
<p>The image buffers are mapped from kernel space to user space using standard
memory mapping to avoid memory copying. But some internal buffers are only
available in the kernel-space.</p>
<div class="section" id="fake-implementation">
<span id="isp-ci-fake-implementation"></span><h3>Fake Implementation<a class="headerlink" href="#fake-implementation" title="Permalink to this headline">¶</a></h3>
<p>The Fake mode was designed to have a &#8220;fake&#8221; <code class="docutils literal"><span class="pre">ioctl()</span></code> call when running the
driver in full user-mode (full user-mode with simulator as HW). This was
implemented by calling the kernel’s library ioctl switch routine directly.
In order to have ioctl macros working on windows the header was copied in a
local <code class="docutils literal"><span class="pre">linux/ioctl.h</span></code>.</p>
<p>In order to make the Fake mode work correctly the <code class="docutils literal"><span class="pre">open()</span></code> and <code class="docutils literal"><span class="pre">close()</span></code>
functions were faked too. Some kernel structures are defined partially in
user-mode so that the functions used to manage the device are the same.</p>
<p>On the kernel-side the <code class="docutils literal"><span class="pre">copy_from_user()</span></code> and <code class="docutils literal"><span class="pre">copy_to_user()</span></code> are
implemented as simple alias for <code class="docutils literal"><span class="pre">memcpy()</span></code>.</p>
<p>The fake <code class="docutils literal"><span class="pre">memap()</span></code> and <code class="docutils literal"><span class="pre">memunmap()</span></code> implementation is as simple as the
ioctl implementation. It does not have to prepare memory. But an extra flag
was added to the struct vma to allow the caller to receive the address of
the required object. The real mode is just calling the standard functions.</p>
</div>
<div class="section" id="interactions">
<span id="isp-ci-kernel-use-cases"></span><h3>Interactions<a class="headerlink" href="#interactions" title="Permalink to this headline">¶</a></h3>
<p>An interaction is <em>direct</em> when initiated directly by the user (e.g. ask for a
frame to be captured) or <em>indirect</em> when done by the CI layer to provide
easier functionalities to the above layer.</p>
<div class="section" id="direct-interaction">
<h4>Direct interaction<a class="headerlink" href="#direct-interaction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Update line-store information (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga3a6e8c572d5f9d13e266a18f625fa027">CI_IOCTL_LINE_GET</a>).</li>
<li>Propose new line-store setup (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaac04220d4566a7a11c456394ca1d190e">CI_IOCTL_LINE_SET</a>).</li>
<li>Update gamma table information (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga9fa1f26483153a48f9c27ec59d61d375">CI_IOCTL_GMAL_GET</a>).</li>
<li>Propose new gamma table (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga6d0ba7d7bb38e59e566019142533ee7a">CI_IOCTL_GMAL_SET</a>).</li>
</ul>
</div>
<div class="section" id="indirect-interaction">
<h4>Indirect interaction<a class="headerlink" href="#indirect-interaction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Register a connection to kernel side (<code class="docutils literal"><span class="pre">open()</span></code>)</li>
<li>Update driver information (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga67bf487c6871f5a186f47ba36b1d6e78">CI_IOCTL_INFO</a>)</li>
<li>Manage Pipeline structures connection  (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaa9477b6322158bf3b69bd38c359ff82d">CI_IOCTL_PIPE_REG</a> and
<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga032f7f94cc29b58266d6a3cf7b8dad23">CI_IOCTL_PIPE_DEL</a>)</li>
<li>Access to image buffers without copy (<code class="docutils literal"><span class="pre">memmap()</span></code> and <code class="docutils literal"><span class="pre">memunmap()</span></code>)</li>
</ul>
<p>More details about the <a class="reference internal" href="ci_appendix_ioctl.html#isp-ci-system-calls-mapping"><span>system calls mapping</span></a>
and <a class="reference internal" href="ci_appendix_ioctl.html#isp-ci-ioctl-tables"><span>ioctl tables</span></a> is available in the appendices.</p>
</div>
</div>
<div class="section" id="img-errors-and-errno-values">
<span id="isp-ci-img-errors-and-errno-values"></span><h3>IMG Errors and Errno values<a class="headerlink" href="#img-errors-and-errno-values" title="Permalink to this headline">¶</a></h3>
<p>Having an interface with the Linux kernel the driver is expected to return
values based from errno. But the standard IMG way is to use
<a class="reference external" href="../doxygen/img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> values for that. In order to provide this behaviour a
mapping of <code class="docutils literal"><span class="pre">errno</span></code> values to <a class="reference external" href="../doxygen/img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> is made (see
<a class="reference external" href="../doxygen/ci__errors_8h.html">ci_errors.h</a> in the kernel sources):</p>
<dl class="docutils">
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#ad0d434b68b5369e6fab16fb96e18c97f">IMG_SUCCESS</a>: 0</dt>
<dd>Success.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#a8e2b1545ca4c08c38ce55a69440326d2">IMG_ERROR_MALLOC_FAILED</a>: <code class="docutils literal"><span class="pre">-ENOMEM</span></code></dt>
<dd>Allocation failed. Used whenever an allocation returns <code class="docutils literal"><span class="pre">NULL</span></code>.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#a03633700831f81eda8de21f9885e4c53">IMG_ERROR_FATAL</a>:</dt>
<dd><p class="first">An unexpected failure occurred.</p>
<p class="last">Default value when converting errors.</p>
</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#af449403c4fe42a28b9ec2f628bdc5496">IMG_ERROR_NOT_SUPPORTED</a>: <code class="docutils literal"><span class="pre">-ENOTSUP</span></code></dt>
<dd>The action is not supported. Used either because the system is not ready
for such action or because the action does not make sense. This is most
likely happening only on development code.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#aaf83f71a2c7762c6a5e2e245be07edff">IMG_ERROR_INVALID_PARAMETERS</a>: <code class="docutils literal"><span class="pre">-EINVAL</span></code></dt>
<dd>Parameters are not legitimate. This should only happen in development code.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#ab81a40f7a1d3e782343d543dd3a3746c">IMG_ERROR_INTERRUPTED</a>: <code class="docutils literal"><span class="pre">-EINTR</span></code></dt>
<dd>An action has been interrupted. The user-side should try again.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#aed9a3bc88f50994fe7da19b8fa3d6113">IMG_ERROR_MEMORY_IN_USE</a>: <code class="docutils literal"><span class="pre">-EADDRINUSE</span></code></dt>
<dd>The memory is already in use at creation or still in used at destruction
time. Should only happen in development code.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#aea9873219eb07f741023654726043b4d">IMG_ERROR_ALREADY_INITIALISED</a>: <code class="docutils literal"><span class="pre">-EEXIST</span></code></dt>
<dd>The structure is already initialised. Should only happen in development
code.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#a3fa68f4a46185c71cbc44f274a45d59c">IMG_ERROR_MINIMUM_LIMIT_NOT_MET</a>: <code class="docutils literal"><span class="pre">-E2BIG</span></code></dt>
<dd>Some requested size is too big to be supported.</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#a594ea8ff93a36dcaecc85417e3add424">IMG_ERROR_COULD_NOT_OBTAIN_RESOURCE</a>: <code class="docutils literal"><span class="pre">-EALREADY</span></code></dt>
<dd>When failures to access resources (e.g. down a semaphore failed).</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#aa6226829ae4d1cebe6e8900ec26fd07b">IMG_ERROR_TIMEOUT</a>: <code class="docutils literal"><span class="pre">-ETIME</span></code></dt>
<dd>Timeout occurred (e.g. when waiting on semaphore down).</dd>
<dt><a class="reference external" href="../doxygen/img__errors_8h.html#acd2f5e620c6542d93c88f63d10a3ae2f">IMG_ERROR_UNEXPECTED_STATE</a>: <code class="docutils literal"><span class="pre">-ECANCELED</span></code></dt>
<dd>An operation was cancelled due to unexpected state.</dd>
</dl>
</div>
<div class="section" id="debug-functions-fake-driver">
<span id="isp-ci-debug-functions"></span><h3>Debug Functions (fake driver)<a class="headerlink" href="#debug-functions-fake-driver" title="Permalink to this headline">¶</a></h3>
<p>When build the CI libraries using the Fake device some debug functionalities
are optionally available. They are enabled at CMake time, and should be
called directly from &#8220;user-space&#8221; (they are implemented in the
&#8220;kernel-space&#8221; but only make sense when running a fake device):</p>
<ul class="simple">
<li>Dump register values – automatically done when triggering a shoot</li>
<li>Over-write register values – done when a register over-write file is given</li>
<li>Read CRC values from memory to help HW verification</li>
</ul>
<p>All the functions are available from the <a class="reference external" href="../doxygen/ci__debug_8h.html">ci_debug.h</a> header and are
using the GZip FileIO library to read or write to file.</p>
<div class="section" id="register-dumping">
<span id="isp-ci-register-dumping"></span><h4>Register Dumping<a class="headerlink" href="#register-dumping" title="Permalink to this headline">¶</a></h4>
<p>Register dumping is simply writing all the registers value to a file.</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/ci__debug_8h.html#a3ab3e2f627c58f4b059a714a6822c557">KRN_CI_DebugDumpCore()</a> dump the core registers</li>
<li><a class="reference external" href="../doxygen/ci__debug_8h.html#a9ca551442f52f28455844e30e53f254f">KRN_CI_DebugDumpContext()</a> dump the registers of a given context</li>
<li><a class="reference external" href="../doxygen/ci__debug_8h.html#a4e9aaf9f733e0b1b7426e1cd1e55293f">KRN_CI_DebugDumpRegisters()</a> dump all registers (core and context)</li>
</ul>
<p>The memory structures that contain registers information can also be written
to file using:</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/ci__debug_8h.html#a50e59628ea64e773f695dd5726d7a07f">KRN_CI_DebugDumpPointersStruct()</a> dump the linked list structure
from memory</li>
<li><a class="reference external" href="../doxygen/ci__debug_8h.html#aca371e0202794d2cf58c5a1cd009f077">KRN_CI_DebugDumpSaveStruct()</a> dump the save structure from memory</li>
<li><a class="reference external" href="../doxygen/ci__debug_8h.html#a63a6bbcbbf3a80dc3fb2dff63b7d08cd">KRN_CI_DebugDumpLoadStruct()</a> dump the load structure from memory</li>
</ul>
<p>The mechanism used to dump registers is to use some REGIO structures that
contain all fields&#8217; information. The first step is to sort registers by
addresses so that the structure can be explored from start to end and its
information used to read registers.</p>
<div class="section" id="register-dumping-file-format">
<h5>Register dumping file format<a class="headerlink" href="#register-dumping-file-format" title="Permalink to this headline">¶</a></h5>
<p>This format was agreed on with the V2500 Simulator to be easily comparable.</p>
<p>For register:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;[offs 0x</span><span class="si">%08X</span><span class="s">] </span><span class="si">%-43s</span><span class="s"> = 0x</span><span class="si">%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regOffset</span><span class="p">,</span> <span class="n">regName</span><span class="p">,</span> <span class="n">regVal</span>
</pre></div>
</div>
<p>If the detailed field option is ticked:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;[mask 0x</span><span class="si">%08X</span><span class="s">]   .</span><span class="si">%-40s</span><span class="s"> = </span><span class="si">%u</span><span class="s"> (0x</span><span class="si">%X</span><span class="s">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fieldMask</span><span class="p">,</span> <span class="n">fieldName</span><span class="p">,</span> <span class="n">fieldVal</span><span class="p">,</span> <span class="n">fieldVal</span>
</pre></div>
</div>
</div>
<div class="section" id="register-dumping-options">
<h5>Register dumping options<a class="headerlink" href="#register-dumping-options" title="Permalink to this headline">¶</a></h5>
<p>Register dumping can be enabled or disabled at running time using
<a class="reference external" href="../doxygen/ci__debug_8c.html#aa9d62adb989ee9a2ff65071e369d2495">KRN_CI_DebugEnableRegisterDump()</a> and
<a class="reference external" href="../doxygen/ci__debug_8c.html#a3459d87238ba401d04eaade097284503">KRN_CI_DebugRegisterDumpEnabled()</a>.</p>
<p>Register dumping can be compressed using GZip FileIO library using the
compile time option <code class="docutils literal"><span class="pre">FELIX_DUMP_COMPRESSED_REGISTERS</span></code> (as an
<code class="docutils literal"><span class="pre">IMG_BOOL8</span></code>). By default the dumping is not compressed.</p>
</div>
<div class="section" id="register-override">
<span id="isp-ci-register-override"></span><h5>Register override<a class="headerlink" href="#register-override" title="Permalink to this headline">¶</a></h5>
<p>The register over-write functionality allows the context registers to be
over-written just after configuration to a specific value. The driver
provides this functionality as a file to load that will be used to overwrite
the load structure submitted every time a capture is triggered (until reset
or changed). From user side the only operation to do is to specify a file to
load for a specific context using <a class="reference external" href="../doxygen/ci__debug_8h.html#a2a3ecdf222da36912ef1e44a2587eded">CI_DebugSetRegisterOverride()</a>.</p>
<p>On kernel side the initialisation is done when the driver is created and
finalisation when it is destroyed. The over-write is called for every
submitted capture using <a class="reference external" href="../doxygen/ci__debug_8c.html#a6c3ca6d510ecfc4e5a9495b0f1f0ee08">KRN_CI_DebugRegisterOverride()</a>. An internal
list for fields IDs (position into the sorted field list that is used for
register dumping) and value is maintained per HW context and used to
over-write some memory location.</p>
<p>This format was agreed on with the V2500 Simulator to be easily used during
testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> 0x</span><span class="si">%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bankName</span><span class="p">,</span> <span class="n">fieldName</span><span class="p">,</span> <span class="n">value</span>
</pre></div>
</div>
<p>Examples of usage are available in <a class="reference internal" href="../test_tools/test_tools.html#isp-tt-register-override"><span>Register override</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="debugfs-real-driver">
<span id="isp-ci-debugfs"></span><h3>DebugFS (real driver)<a class="headerlink" href="#debugfs-real-driver" title="Permalink to this headline">¶</a></h3>
<p>DebugFS is a GNU/Linux feature that allows some variables to be accessible
as files in a specific location of the kernel. This is only available when
building the real driver with <code class="docutils literal"><span class="pre">CI_DEBUG_FUNCTIONS</span></code> enabled.</p>
<p>DebugFS is implemented as part of the module initialisation in
<code class="docutils literal"><span class="pre">kernel_src/ci_init_km.c</span></code>.</p>
<p>Several files may be available and will vary from versions to version but
the following lists can be used as a reference of what to expect in the CI
debugFS variables. The files should be located in
<code class="docutils literal"><span class="pre">/sys/kernel/debug/imgfelix/</span></code> and root privileges are needed to access
them (DebugFS needs to be supported by the chosen kernel and the location
mounted).</p>
<p>See also <a class="reference internal" href="ci_appendix.html#isp-ci-adding-debugfs-counter"><span>CI Appendix: Adding a new DebugFS counter</span></a>.</p>
<div class="section" id="general-entries">
<span id="isp-ci-debugfs-general"></span><h4>General entries<a class="headerlink" href="#general-entries" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>DevMemMaxUsed:</dt>
<dd>Maximum amount of device memory used since insmod.</dd>
<dt>DevMemUsed:</dt>
<dd>Current amount of device memory used.</dd>
<dt>DriverNConnections:</dt>
<dd>Number of connection to the driver (i.e. different calls to <code class="docutils literal"><span class="pre">open()</span></code>).</dd>
<dt>DriverNServicedHardInt:</dt>
<dd>Number of timed the top-half of the interrupt handler has been called.</dd>
<dt>DriverNServicedThreadInt:</dt>
<dd>Number of timed the bottom-half of the interrupt handler has been called.
This should be the same than the number of time the top-half has been
called.</dd>
<dt>DriverLongestHardIntUS:</dt>
<dd>Longest time in μs (microseconds) (10^-6) spent in top-half interrupt handler.</dd>
<dt>DriverLongestThreadIntUS:</dt>
<dd>Longest time in μs (microseconds) (10^-6) spent in bottom-half interrupt handler.</dd>
</dl>
</div>
<div class="section" id="context-entries-is-context-number">
<span id="isp-ci-debugfs-context"></span><h4>Context entries (# is context number)<a class="headerlink" href="#context-entries-is-context-number" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>DriverCTX#Active:</dt>
<dd>Is the context active?</dd>
<dt>DriverCTX#Int:</dt>
<dd>Number of interrupts received.</dd>
<dt>DriverCTX#Int_DoneAll:</dt>
<dd>Number of interrupt frame done all received.</dd>
<dt>DriverCTX#Int_Ignore:</dt>
<dd>Number of interrupt error ignore received.</dd>
<dt>DriverCTX#Int_Start:</dt>
<dd>Number of interrupts frame start received.</dd>
<dt>DriverCTX#TriggeredHW:</dt>
<dd>Number of frames triggered in HW (pushed to be captured).</dd>
<dt>DriverCTX#TriggeredSW:</dt>
<dd>Number of frames triggered in SW (pushed to be captured). May not have
been pushed in HW yet.</dd>
</dl>
</div>
<div class="section" id="external-data-generator-entries-is-datagen-number">
<span id="isp-ci-debugfs-external-dg"></span><h4>External Data-generator entries (# is datagen number)<a class="headerlink" href="#external-data-generator-entries-is-datagen-number" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>DriverDG#Int:</dt>
<dd>Number of interrupts received.</dd>
<dt>DriverDG#SubmittedSW:</dt>
<dd>Number of frames triggered in SW (may not have been pushed to HW yet).</dd>
<dt>DriverDG#TriggeredHW:</dt>
<dd>Number of frames triggered in HW.</dd>
<dt>DriverDGNServicedHardInt:</dt>
<dd>If supporting external DG the number of time the top-half of the external
DG interrupt handler has been called. Otherwise does not exists.
This should be the same than the number of time the top-half has been
called (DriverNServicedHardInt).</dd>
<dt>DriverSGNServicedThreadInt:</dt>
<dd>If supporting external DG the number of time the bottom-half of the external
DG interrupt handler has been called. Otherwise does not exists.
This does not have to be the same than the number of calls to the top-half
(see <a class="reference internal" href="#isp-ci-bottom-half"><span>Bottom Half - Thread context</span></a>).</dd>
<dt>DriverDGLongestHardIntUS:</dt>
<dd>Longest time in μs (microseconds) (10^-6) spent in top-half interrupt
handler.</dd>
<dt>DriverDGLongestThreadIntUS:</dt>
<dd>Longest time in μs (microseconds) (10^-6) spent in bottom-half interrupt
handler.</dd>
</dl>
</div>
<div class="section" id="internal-data-generator-entries-is-internal-dg-number">
<span id="isp-ci-debugfs-internal-dg"></span><h4>Internal Data-generator entries (# is internal DG number)<a class="headerlink" href="#internal-data-generator-entries-is-internal-dg-number" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>DriverIntDG#Int_EndOfFrame:</dt>
<dd>Number of end of frame interrupt received.</dd>
<dt>DriverIntDG#Int_Error:</dt>
<dd>Number of interrupt error received.</dd>
</dl>
</div>
</div>
<div class="section" id="register-access-for-debugging-purposes">
<span id="isp-ci-debug-registers"></span><h3>Register access for debugging purposes<a class="headerlink" href="#register-access-for-debugging-purposes" title="Permalink to this headline">¶</a></h3>
<p>Some of following functions <strong>will fail</strong> if the kernel module is not compiled
with the debug functions (the associated IOCTL will be ignored).</p>
<p>It is always possible for the user-space to query the following states:</p>
<ul class="simple">
<li>the current HW timestamps using <a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#gab0ee5ca19e1b9be82f31b8052a6546df">CI_DriverGetTimestamp()</a></li>
<li>the current RTM info status using <a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#ga12b51f6318b32ab94ea84fb847aef270">CI_DriverGetRTMInfo()</a>.
The RTM info is a HW debugging feature, please refer to the HW TRM for
more details.</li>
<li>the current status of a gasket using <a class="reference external" href="../doxygen/group___c_i___a_p_i___g_a_s_k_e_t.html#gab0798b36249913ad0a4d57d208d68c6f">CI_GasketGetInfo()</a></li>
<li>the HW read only registers are also available in the
<a class="reference external" href="../doxygen/struct_c_i___c_o_n_n_e_c_t_i_o_n.html#a15958f8c59d3fa65ef1d138f190a469a">CI_CONNECTION::sHWInfo</a> object (see <a class="reference external" href="../doxygen/struct_c_i___h_w_i_n_f_o.html">CI_HWINFO</a> structure for
details of what is available).</li>
</ul>
<p>If the kernel module was compiled with debug functions then the following
functions can also be used for register access:</p>
<ul class="simple">
<li>read any register or memory location using <a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#ga7888492ac8dff65529d4920d4466faa2">CI_DriverDebugRegRead()</a></li>
<li>write any register or memory location using <a class="reference external" href="../doxygen/group___c_i___a_p_i___d_r_i_v_e_r.html#ga8624e043dca768b547db21e70348fb9a">CI_DriverDebugRegWrite()</a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When using the register or memory access the user is expected to give an
integer that identifies the memory bank. The enum present in <code class="docutils literal"><span class="pre">ci_ioctrl.h</span></code>
<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gae035a82543cf6819903d40a5eb8d896c">CI_DEBUG_BANKS</a> contains the values. This is debug feature therefore
the header may not be accessible on every include context. The user can
use integer instead of the enum values.</p>
<p>For example at time of writing:</p>
<div class="last highlight-c"><div class="highlight"><pre><span class="k">enum</span> <span class="n">CI_DEBUG_BANKS</span> <span class="p">{</span>
    <span class="n">CI_BANK_CORE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">CI_BANK_GMA</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="cm">/** from CI_BANK_CTX to (CI_BANK_CTX + CI_N_CONTEXT -1) */</span>
    <span class="n">CI_BANK_CTX</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="cm">/** from CI_BANK_GASKET to (CI_BANK_GASKET + CI_N_IMAGERS -1) */</span>
    <span class="n">CI_BANK_GASKET</span> <span class="o">=</span> <span class="n">CI_BANK_CTX_MAX</span><span class="p">,</span>
    <span class="cm">/** from CI_BANK_IFF to (CI_BANK_IFF + CI_N_IIF_DATAGEN -1) */</span>
    <span class="n">CI_BANK_IIFDG</span> <span class="o">=</span> <span class="n">CI_BANK_GASKET_MAX</span><span class="p">,</span>
    <span class="n">CI_BANK_MEM</span> <span class="o">=</span> <span class="n">CI_BANK_IIF_MAX</span><span class="p">,</span>

    <span class="cm">/** not an actual value, if &gt;= then bank enum is invalid */</span>
    <span class="n">CI_BANK_N</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>For example to access the all context status register (example offset 0x10 <em>not
an actual value</em>) the user is expected to do:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">IMG_RESULT</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">IMG_UINT32</span> <span class="n">status</span><span class="p">;</span>  <span class="c1">// context 1 status</span>
<span class="kt">int</span> <span class="n">ctx</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ctx_base</span> <span class="o">=</span> <span class="n">CI_BANK_CTX</span><span class="p">;</span> <span class="c1">// or 2 if ci_ioctrl.h is not available in this scope</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">reg_ctx_status</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>

<span class="cm">/* assuming pConnection is an existing CI_CONNECTION opened with success */</span>

<span class="k">for</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ctx</span> <span class="o">&lt;</span> <span class="n">pConnection</span><span class="o">-&gt;</span><span class="n">sHWInfo</span><span class="p">.</span><span class="n">nctx</span><span class="p">;</span> <span class="n">ctx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">CI_DriverDebugRegRead</span><span class="p">(</span><span class="n">pConnection</span><span class="p">,</span> <span class="n">ctx_base</span><span class="o">+</span><span class="n">ctx</span><span class="p">,</span> <span class="n">reg_ctx_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IMG_SUCCESS</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;failed to read registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;context[%d] status 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interrupt-management">
<span id="isp-ci-interrupt-management"></span><h2>Interrupt Management<a class="headerlink" href="#interrupt-management" title="Permalink to this headline">¶</a></h2>
<p>The scope of this section is the different actions the kernel-side driver
does to manage HW interrupts. Most of device driver for GNU/Linux the
interrupts are handled using the Top/Bottom halves mechanism.</p>
<p>The Top Half is triggered when the HW interrupt is received. As it is in the
kernel interrupt context it has to be completed as fast as possible. Its
behaviour is detailed in the Top Half paragraph.</p>
<p>The Bottom Half is implemented using a standard work-queue that will perform
some operations later in time. Its behaviour is detailed in the Bottom Half
paragraph.</p>
<p>The V2500 driver does not have much work to do once an interrupt
is received but it implements its top/bottom half approach by taking advantage
of a GNU/Linux function: <code class="docutils literal"><span class="pre">request_threaded_irq()</span></code>. This interface allows 2 interrupt
handler functions (one is the top half, the threaded one
is the bottom half).</p>
<div class="section" id="request-and-release-of-the-interrupt-line">
<span id="isp-ci-request-and-release-interrupt"></span><h3>Request and release of the interrupt line<a class="headerlink" href="#request-and-release-of-the-interrupt-line" title="Permalink to this headline">¶</a></h3>
<p>The CI driver request the interrupt line when the 1st call to <code class="docutils literal"><span class="pre">open()</span></code> is
performed - precisely when creating a connection object and realising that
no other connection object exist. This can fail in that case the system call
will fail to connect to the device.</p>
<p>The interrupt line is released at the last call to <code class="docutils literal"><span class="pre">close()</span></code> - precisely
when destroying the connection object and realising that it is the last one.</p>
<p>The request to the IRQ is implemented in the Platform Device function:
<a class="reference external" href="../doxygen/group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gadd66adf1947f3950f4c7b5360e6f7740">SYS_DevRequestIRQ()</a>.</p>
</div>
<div class="section" id="configured-interrupts">
<span id="isp-ci-configured-interrupts"></span><h3>Configured interrupts<a class="headerlink" href="#configured-interrupts" title="Permalink to this headline">¶</a></h3>
<p>The CI driver uses a 2 interrupts from the V2500 HW:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">INT_FRAME_DONE_ALL</span></code>: this interrupt signals that the capture of a frame
is finished and that device memory is updated.</li>
<li><code class="docutils literal"><span class="pre">INT_START_OF_FRAME_RECEIVED</span></code>: this interrupt is used to read the gasket
frame counter and verify if frames we missed (expecting the gasket frame
count to increment by one from last read).</li>
</ul>
<p>The other possible interrupts from the HW that could be interesting are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">INT_CONFIGURATION_LOADED</span></code>: that signals a configuration has been loaded
from the HW pending list. This could be used to have a closer-grained
management of the semaphore that allows the driver to submit elements to the
HW. Currently this semaphore is incremented when the completed frame is
processed.</li>
<li><code class="docutils literal"><span class="pre">INT_ERROR_IGNORE</span></code>: this interrupt is generated to signal that the
context could not retrieve a frame. This interrupt may become interesting to
try to realise that the bandwidth limitation of the HW is not respected.</li>
</ul>
</div>
<div class="section" id="top-half-interrupt-context">
<span id="isp-ci-top-half-interrupt-context"></span><h3>Top Half - Interrupt context<a class="headerlink" href="#top-half-interrupt-context" title="Permalink to this headline">¶</a></h3>
<p>This runs in interrupt context in the kernel. It cannot access user-space
memory and should complete as fast as possible. It is implemented in
<a class="reference external" href="../doxygen/group___h_w___c_i.html#ga80f05ed738a99cf1ba397b9c79f7f3cf">HW_CI_DriverHardHandleInterrupt()</a>.</p>
<p>All read statuses are stored into a structure allocated on the stack. If
interrupts were detected a status structure is allocated using the
<code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> heap of kmalloc and enqueued into the driver&#8217;s
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___d_r_i_v_e_r.html#af6ecb19e377db77ae38b1f7aebb0348a">KRN_CI_DRIVER::sWorkqueue</a>.</p>
<div class="section" id="contexts">
<h4>Contexts<a class="headerlink" href="#contexts" title="Permalink to this headline">¶</a></h4>
<p>When the interrupt is signalled the driver loops through all contexts, for
each context it reads:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">INTERRUPT_STATUS</span></code> register</li>
<li><code class="docutils literal"><span class="pre">INTERRUPT_ENABLE</span></code> register to know if interrupts were received while disabled</li>
<li><code class="docutils literal"><span class="pre">LAST_FRAME_INFO</span></code> to know if we missed interrupts</li>
</ul>
<p>If the interrupt status it different than 0 the status is stored and will be
passed to the bottom-half.</p>
<p>In all cases it resets the interrupts using the <code class="docutils literal"><span class="pre">INTERRUPT_CLEAR</span></code> register.</p>
</div>
<div class="section" id="internal-data-generator">
<h4>Internal Data Generator<a class="headerlink" href="#internal-data-generator" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">DG_INTER_STATUS</span></code> is read as well as the frame count. It is stored and
sent to the bottom-half regardless of the value.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The frame count is accessed through <code class="docutils literal"><span class="pre">HW_CI_DatagenFrameCount()</span></code> function.</p>
</div>
</div>
<div class="section" id="gasket">
<h4>Gasket<a class="headerlink" href="#gasket" title="Permalink to this headline">¶</a></h4>
<p>The gasket can have interrupts but the driver does not enable them. The frame
count is however read for each gasket as it will be used by the bottom-half.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The frame count is accessed through <code class="docutils literal"><span class="pre">HW_CI_GasketFrameCount()</span></code> function.</p>
</div>
</div>
<div class="section" id="mmu">
<h4>MMU<a class="headerlink" href="#mmu" title="Permalink to this headline">¶</a></h4>
<p>The driver also verifies interrupt status for the MMU unit. But if an
interrupt is sent from the MMU it means an erroneous configuration was set
and the only way to recover is to start the capture again. See
<a class="reference internal" href="ci_appendix_mmufault.html#isp-ci-debugging-a-page-fault"><span>CI Appendix: Debugging a Page Fault</span></a> to know what to do in case of MMU issues.</p>
</div>
<div class="section" id="external-data-generator">
<h4>External Data Generator<a class="headerlink" href="#external-data-generator" title="Permalink to this headline">¶</a></h4>
<p>If the driver was compiled with External Data Generator support then the
external data generator interrupt handler function
<a class="reference external" href="../doxygen/group___d_g___k_e_r_n_e_l.html#ga934235d13096c8c962d6ea4a41b6c801">KRN_DG_DriverHardHandleInterrupt()</a> is called. The return code from that
handler is stored and will be used in the bottom-half to know if the threaded
equivalent should be called or not.</p>
</div>
<div class="section" id="system-device-clear">
<h4>System Device clear<a class="headerlink" href="#system-device-clear" title="Permalink to this headline">¶</a></h4>
<p>The last operation is to call the <code class="docutils literal"><span class="pre">SYS_DevClearInterrupt()</span></code> that can be
implemented to clear additional registers on the interrupt lines.</p>
<p>For example IMG FPGA platform needs to clear an additional register to put the
line down.</p>
</div>
</div>
<div class="section" id="bottom-half-thread-context">
<span id="isp-ci-bottom-half"></span><h3>Bottom Half - Thread context<a class="headerlink" href="#bottom-half-thread-context" title="Permalink to this headline">¶</a></h3>
<p>This should be automatically called by the kernel when <code class="docutils literal"><span class="pre">IRQ_WAKE_THREAD</span></code> is
returned by the Top half. This can sleep and deals with the work provided by
the top half.</p>
<div class="section" id="id18">
<h4>Contexts<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>For <code class="docutils literal"><span class="pre">INT_START_OF_FRAME_RECEIVED</span></code> it reads the gasket frame counter and
compares it with the last read counter. This value may not have changed for
the first frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the Internal Data Generator is replacing that gasket then the
frame counter is read from the internal Data Generator instead.</p>
</div>
<p>For <code class="docutils literal"><span class="pre">INT_FRAME_DONE_ALL</span></code> it does:</p>
<ol class="arabic simple">
<li>Reads the <code class="docutils literal"><span class="pre">LAST_FRAME_INFO</span></code> status and get the last used frame ID
from it (<code class="docutils literal"><span class="pre">LAST_CONTEXT_TAG</span></code> field).</li>
<li>Get the Pipeline structure associated to that HW context from the driver
object.</li>
<li>Get the 1st frame on the Pipeline’s pending list - the element is
<em>removed</em> from the list.</li>
<li>Add the frame to the processed list and increment the associated semaphore</li>
<li>If this frame’s ID is different from the last used one go back to 3.</li>
</ol>
</div>
<div class="section" id="id19">
<h4>Internal Data Generator<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>The driver also checks the Internal Data Generator interrupts:</p>
<ol class="arabic simple">
<li>Read <code class="docutils literal"><span class="pre">DG_INTER_STATUS</span></code> from the status - if it signals no interrupt no
more processing is done for that datagen.</li>
<li>It moves the head of the Busy list in the Processed list.</li>
<li>If the Busy list still has elements in it trigger them in the HW.</li>
</ol>
<p>It is possible that the Internal Data Generator cannot process a frame if
the bandwidth limitation is not respected. In that case the HW cannot
recover therefore the capture has to be stopped and started again. It is
impossible to continue triggering frames on an erroneous internal data
generator.</p>
</div>
<div class="section" id="id20">
<h4>External Data Generator<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>If the driver was compiled with External Data Generator support then the
external data generator interrupt handler function
<a class="reference external" href="../doxygen/group___d_g___k_e_r_n_e_l.html#gac194a09f362379541b5d516477c01778">KRN_DG_DriverThreadHandleInterrupt()</a> is called according to the return
code from that was stored in the top-half.</p>
</div>
</div>
</div>
<div class="section" id="memory-mapping-unit-mmu">
<span id="isp-ci-memory-mapping-unit"></span><h2>Memory Mapping Unit (MMU)<a class="headerlink" href="#memory-mapping-unit-mmu" title="Permalink to this headline">¶</a></h2>
<p>Documentation about the MMU HW should be delivered as part of the HW
package. The reference document is named <em>Video Bus 4 MMU Functional
Specification</em>.</p>
<p>The MMU HW has 4 directory entries but only 2 can be used at once <a class="footnote-reference" href="#id32" id="id21">[1]</a>. The
V2500 IP has 1 internal MMU that manages memory access for the Contexts and
internal data generator. The FPGA build also has an external MMU that
manages memory access for the external Data Generators.</p>
<p>The CI Driver (kernel side) manages the internal MMU. Each Pipeline object
creates its own software heap (i.e. manages its range of device virtual
addresses, see <a class="reference internal" href="#isp-ci-virtual-address-management"><span>Virtual Address management and heaps</span></a>) and the device
memory is mapped to the MMU when the capture is started (and unmapped when
it is stopped).</p>
<p>The internal data generator shares the same requestor as the 1st context
(see <a class="reference internal" href="#isp-ci-mmu-requestors"><span>MMU Requestors</span></a>) therefore they have to share the same
directory entry. However the virtual addresses heaps do not overlap between
Context memory and internal data generator (see
<a class="reference internal" href="#isp-ci-virtual-address-management"><span>Virtual Address management and heaps</span></a>). The sharing of a requestor may
create trouble as the device MMU may need cache flushing (see
<a class="reference internal" href="#isp-ci-mmu-cache-management"><span>MMU Cache management and flushing</span></a>).</p>
<p>The Data Generators part of the driver manages the external MMU. Each DG has
its own software heap and memory is mapped when starting shooting.</p>
<p>It is possible to disable the memory translation to directly give physical
address to the HW (virtual address, heaps or tiling is not supported when
bypassing the MMU) when creating the kernel structures. This requires the
memory to be allocated in continuous blocks. The register to configure this
behaviour is <code class="docutils literal"><span class="pre">MMU_ADDRESS_CONTROL::MMU_BYPASS</span></code>.</p>
<p>When enabled the physical address of the page used as directories should be
written into <code class="docutils literal"><span class="pre">MMU_BANK_INDEX</span></code> register.</p>
<p>The MMU can be stopped from processing memory requests using the
<code class="docutils literal"><span class="pre">MMU_CONTROL1::MMU_PAUSE_SET</span></code> register. The pause is removed using
<code class="docutils literal"><span class="pre">MMU_CONTROL1::MMU_PAUSE_CLEAR</span></code>.</p>
<div class="section" id="mmu-size">
<span id="isp-ci-mmu-size"></span><h3>MMU size<a class="headerlink" href="#mmu-size" title="Permalink to this headline">¶</a></h3>
<p>The MMU manages virtual addresses that are 32b wide but can support
different physical address size. In V2500 the typical size is 40b physical.
The supported page size is currently 4kB (as supported by Linux for x86 or
arm). The MMU HW cannot support other sizes than 4kB but it is possible to
modify the driver’s allocator to support such configurations.</p>
<p>To support the wider physical range the MMU can support shifting the
physical addresses (configurable in
<code class="docutils literal"><span class="pre">MMU_ADDRESS_CONTROL::MMU_ENABLE_EXT_ADDRESSING</span></code>). Note that when the
extended addressing is enabled not only the entries in the page entries but
also the directory page address should be shifted using that mechanism.</p>
<p>The size of the physical memory supported by the current MMU is available in
the register <code class="docutils literal"><span class="pre">MMU_CONFIG0::EXTENDED_ADDR_RANGE</span></code>.</p>
</div>
<div class="section" id="mmu-requestors">
<span id="isp-ci-mmu-requestors"></span><h3>MMU Requestors<a class="headerlink" href="#mmu-requestors" title="Permalink to this headline">¶</a></h3>
<p>The V2500 HW interacts with the MMU through <em>requestors</em>. A requestor is an
identifier that is used by the MMU as a reference to choose which directory
entry to use. The driver must configure the requestor to use a specified
directory. For V2500 the following values are used:</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">HW Element</th>
<th class="head">MMU Requestor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Felix Context 0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Felix Context 1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Felix Context N</td>
<td>N</td>
</tr>
<tr class="row-odd"><td>Internal Data Generator</td>
<td>0</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">HW Element</th>
<th class="head">External MMU Requestor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>External Data Generator 0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>External Data Generator 1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>External Data Generator N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>In the MMU HW the requestors are configured using the <code class="docutils literal"><span class="pre">MMU_BANK_INDEX</span></code>
register.</p>
</div>
<div class="section" id="mmu-interrupts">
<span id="isp-ci-mmu-interrupts"></span><h3>MMU Interrupts<a class="headerlink" href="#mmu-interrupts" title="Permalink to this headline">¶</a></h3>
<p>Interrupts from the MMU are generated when a page fault is signalled. The
MMU does not have an interrupt management of its own but requires its
attached IP to signal it with its own flags and line.</p>
<p>The <code class="docutils literal"><span class="pre">MMU_STATUS0</span></code> and <code class="docutils literal"><span class="pre">MMU_STATUS1</span></code> registers can be used to figure out the
source of the fault:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">MMU_STATUS0::MMU_PF_N_RW</span></code> signals if the fault is a page fault (if 0 it
is read/write flag error).</li>
<li><code class="docutils literal"><span class="pre">MMU_STATUS1::MMU_FAULT_RNW</span></code> signals if the fault was during a read (if
0 a write) operation.</li>
<li><code class="docutils literal"><span class="pre">MMU_STATUS1::MMU_FAULT_INDEX</span></code> specifies which directory generated the
fault</li>
<li><code class="docutils literal"><span class="pre">MMU_STATUS0::MMU_FAULT_ADDR</span></code> is the virtual address that generated the
fault</li>
</ul>
<p>The V2500 driver does not handle such interrupt besides printing the error
but it uses the information to crawl the page table entries and print the
stored values to help debugging.</p>
<p>The MMU_CONTROL1::MMU_FAULT_CLEAR register should clear the fault and send
the memory request back to the MMU to try to translate again.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>MMU interrupt can only occur if the system was badly configured.</p>
<p class="last">See <a class="reference internal" href="ci_appendix_mmufault.html#isp-ci-debugging-a-page-fault"><span>CI Appendix: Debugging a Page Fault</span></a> to try debugging page faults.</p>
</div>
</div>
<div class="section" id="virtual-address-management-and-heaps">
<span id="isp-ci-virtual-address-management"></span><h3>Virtual Address management and heaps<a class="headerlink" href="#virtual-address-management-and-heaps" title="Permalink to this headline">¶</a></h3>
<p>In this section heap means &#8220;a range of virtual address that is supposed to
be used for one defined purpose&#8221; (e.g. virtual address range from <code class="docutils literal"><span class="pre">0x0</span></code> to
<code class="docutils literal"><span class="pre">0x1FFFF</span></code> is for data buffer, the range from <code class="docutils literal"><span class="pre">0x20000</span></code> to <code class="docutils literal"><span class="pre">0xFFFFFF</span></code>
is for image buffers).</p>
<div class="section" id="hardware-heap-management">
<h4>Hardware heap management<a class="headerlink" href="#hardware-heap-management" title="Permalink to this headline">¶</a></h4>
<p>The MMU HW does not manage &#8220;heaps&#8221; as such. But the MMU HW supports
different area of memory to be used as tiled buffers. The configuration for
the tiling is done through <code class="docutils literal"><span class="pre">MMU_TILE_MIN_ADDR_T</span></code>, <code class="docutils literal"><span class="pre">MMU_TILE_MAX_ADDR_T</span></code> and
<code class="docutils literal"><span class="pre">MMU_TILE_CFG</span></code> table registers.</p>
<p>V2500 MMU HW supports tiling and the driver can be configured at insmod time
to choose between the 2 possible tiling schemes (<a class="reference internal" href="../getting_started.html#isp-gsg-insmod-options"><span>Getting Started
Guide</span></a>). The choice of tiling a buffer should then
be done at allocation/import time.</p>
<p>The 2 tiling schemes are:</p>
<ul class="simple">
<li>256 Bytes x 16 lines</li>
<li>512 Bytes x 8 lines</li>
</ul>
</div>
<div class="section" id="software-heap-management">
<h4>Software heap management<a class="headerlink" href="#software-heap-management" title="Permalink to this headline">¶</a></h4>
<p>The virtual address management is done by heaps from the IMGMMU library. The
driver configures those heaps at driver creation in
<code class="docutils literal"><span class="pre">kernel_src/ci_internal.c</span></code> using an array of heaps per Pipeline object.
The number of heaps is defined as <code class="docutils literal"><span class="pre">CI_N_HEAPS</span></code> in
<a class="reference external" href="../doxygen/ci__kernel__structs_8h.html">ci_kernel_structs.h</a> and has 3 types of heaps as described later. As
mentioned previously each context uses a directory therefore they can use
the same virtual addresses. The &#8220;software&#8221; heaps are:</p>
<ol class="arabic simple">
<li>The Data Heap (<code class="docutils literal"><span class="pre">CI_DATA_HEAP</span></code>) contains the V2500 data structures.
It has to be big enough to hold the Lens Shading matrix, the DPF read map
and all the data structures that could be needed to fill up the Linked List
register (HW Load structure, HW Save structure and HW Link list structure
and DPF output map – rounded up to <code class="docutils literal"><span class="pre">PAGE_SIZE</span></code> which is usually 4kBytes).
The usual needed size is around 20 MB for 16 buffers. The heap is configured
to use the first 256MB of virtual memory.</li>
<li>The internal data generator heap (<code class="docutils literal"><span class="pre">CI_INTDG_HEAP</span></code>) contains the
internal data generator frames.</li>
<li>The Image Heap (<code class="docutils literal"><span class="pre">CI_IMAGE_HEAP</span></code>) contains the image buffers that are not tiled.
It is configured to be half of the remaining memory after the Data Heap.</li>
<li>The Tiled Image Heaps (<code class="docutils literal"><span class="pre">CI_TILED_IMAGE_HEAP0</span></code> to
<code class="docutils literal"><span class="pre">CI_TILED_IMAGE_HEAP3</span></code>) are similar to the image heap but for tiled
images. However because of the HW MMU limitation about the tiling stride
each HW context has its own heap (i.e. if the Pipeline object is attached to
HW context 1 it should use <code class="docutils literal"><span class="pre">CI_TILED_IMAGE_HEAP1</span></code> for its tiled images).</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Heap</th>
<th class="head">V2500 Virtual address range</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Data Heap</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0x00001000</span></code> – <code class="docutils literal"><span class="pre">0x0FFFFFFF</span></code></p>
<p>65,535 pages, ~256 MB (missing the 1st page)</p>
<p class="last">Entries 0:1 to 63:1023</p>
</td>
</tr>
<tr class="row-odd"><td>Image Heap</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0x10000000</span></code> – <code class="docutils literal"><span class="pre">0x7FFFFFFF</span></code></p>
<p>458,752 pages, ~1.75 GB</p>
<p class="last">Entries 64:0 to 511:1023</p>
</td>
</tr>
<tr class="row-even"><td><p class="first">Tiled Image Heaps</p>
<p class="last"><strong>Shared equally
amongst each
context</strong></p>
</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0x80000000</span></code> – <code class="docutils literal"><span class="pre">0xEFFFFFFF</span></code></p>
<p>458,752 pages, ~1.75 GB</p>
<p class="last">Entries 512:0 to 959:1023</p>
</td>
</tr>
<tr class="row-odd"><td>Internal DG Heap</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0xF0000000</span></code> – <code class="docutils literal"><span class="pre">0xFFFFEFFF</span></code></p>
<p>65,535 pages, ~256 MB (missing the last page)</p>
<p class="last">Entries 960:0 to 1023:1022</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the usage of the Raptor IP needs
more virtual memory it is recommended to simply change the
computation of the sizes by forcing the unused heaps to 0 when in
<code class="docutils literal"><span class="pre">kernel_src/ci_internal.c</span></code> <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga0f5a0ffb3ae06074daf27a452d5eae24">KRN_CI_DriverCreate()</a>.</p>
</div>
<p>The heaps for the External Data Generator are similar but do not support
tiled images. Moreover the Data Heap is not used currently (the data
generator is driven manually rather than using its linked list) therefore
the Data Heap is put as the last 256MB of memory.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Heap</th>
<th class="head">V2500 Virtual address range (External)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Data Heap</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0xE0000000</span></code> – <code class="docutils literal"><span class="pre">0xFFFFEFFF</span></code></p>
<p>65,535 pages, ~256 MB (missing the last page)</p>
<p class="last">Entries 896:0 to 1023:1022</p>
</td>
</tr>
<tr class="row-odd"><td>Image Heap</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0x00001000</span></code> – <code class="docutils literal"><span class="pre">0xDFFFFFFF</span></code></p>
<p>917,503 pages, ~3.5GB (missing the 1st page)</p>
<p class="last">Entries 0:1 to 895:1023</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Neither the V2500 nor External Data Generator heaps uses the first or
last page of the system. This serves a double purpose:</p>
<ul class="last simple">
<li>Virtual address 0 (in fact &lt;0x1000) are invalid</li>
<li>Avoid trouble with genalloc.c when using the GNU/Linux kernel (see
<a class="reference internal" href="#isp-ci-memory-band-management"><span>Memory band management (genalloc)</span></a>) (rounding errors when reaching 4GB
on 32b systems).</li>
</ul>
</div>
<p><strong>Example of heap address</strong></p>
<p>Example for tiled heaps with a HW configuration that has 2 contexts:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Heap</th>
<th class="head">V2500 Virtual address range</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tiled Image Heap 0</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0x80000000</span></code> – <code class="docutils literal"><span class="pre">0xB7FFEFFF</span></code></p>
<p>229,375 pages, ~895 MB</p>
<p class="last">Entries 512:0 to 735:1022</p>
</td>
</tr>
<tr class="row-odd"><td>Tiled Image Heap 1</td>
<td><p class="first"><code class="docutils literal"><span class="pre">0xB7FFF000</span></code> – <code class="docutils literal"><span class="pre">0xEFFFDFFF</span></code></p>
<p>229,375 pages, ~895 MB</p>
<p class="last">Entries 735:1023 to 959:1021</p>
</td>
</tr>
<tr class="row-even"><td>Tiled Image Heap 2</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>Tiled Image Heap 3</td>
<td>None</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="mmu-cache-management-and-flushing">
<span id="isp-ci-mmu-cache-management"></span><h3>MMU Cache management and flushing<a class="headerlink" href="#mmu-cache-management-and-flushing" title="Permalink to this headline">¶</a></h3>
<p>The MMU HW supports two cache management operations: invalidate and flush.
The HW has 2 caches: one for the directory entries and one for the page
table entries. Both cache are unique per directory and are invalidated using
a repeated field.</p>
<p>Any update related to the directory page (either the update of the base
address in <code class="docutils literal"><span class="pre">MMU_BANK_INDEX</span></code> register or the addition of a page into the
directory) should invalidate the 2 caches using the correct
<code class="docutils literal"><span class="pre">MMU_CONTROL1::MMU_INVALIDC</span></code>.</p>
<p>Any update in the page tables entries should invalidate the corresponding
&#8220;table cache&#8221; for that directory using <code class="docutils literal"><span class="pre">MMU_CONTROL1::MMU_FLUSH</span></code>.</p>
<p>It is expected that the memory managed by the MMU unit is un-cached in the
CPU MMU.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal"><span class="pre">MMU_INVALIDC</span></code> action invalidates both caches while <code class="docutils literal"><span class="pre">MMU_FLUSH</span></code>
only invalidates the table cache.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Internal Data Generator and Context 0 potential issues</p>
<p class="last">The internal Data Generator and the 1st Context share the same directory
entry in the MMU. Therefore flushing the cache for directory 0, when
manipulating the mapping of one, may affect the memory latency of the
other. This can cause frames to be dropped if the system is used close
to its output bandwidth limit.</p>
</div>
</div>
<div class="section" id="mmu-tiling-information">
<span id="isp-ci-tiling-information"></span><h3>MMU Tiling information<a class="headerlink" href="#mmu-tiling-information" title="Permalink to this headline">¶</a></h3>
<p>The tiling of the memory is handled by the device MMU entirely. The process
is transparent to the ISP HW. However enabling such output has effects on the
SW as the MMU has several expectations.</p>
<p>When enabling tiling in the MMU expects a region of the virtual memory to be
reserved (called heap). This region is shared amongst ALL MMU contexts,
therefore the driver made the decision to allow only 1 tiled region per MMU
context (as explained in the <a class="reference internal" href="#isp-ci-virtual-address-management"><span>Virtual Address management and heaps</span></a>).</p>
<p>For each tiled heap the SW has to define one tiling stride. Therefore any
tiled buffer has to use the <strong>same</strong> tiling stride in a given Pipeline
object. For example if the ISP outputs both YUV and RGB it is expected that
the YUV stride will be smaller: 420 8b YUV needs 1 Byte per pixel while RGB
usually needs 3 or 4 Bytes per pixels as R/G/B are interleaved. If both YUV
and RGB are tiled then they have to share the same tiling stride: the
biggest is therefore chosen, the YUV buffer will be a lot bigger than it
needs to be.</p>
<p>When using tiling it is also important that the 1st virtual address used for
a buffer is at the start of a tile (so that the transformation using the
tiling scheme does not go backward in virtual space). To do so the driver
reserves additional virtual memory. The size of the additional memory
depends on the selected tiled stride.</p>
<p>The maximum and minimum tiling strides supported by the SW are defined in
<a class="reference external" href="../doxygen/ci__kernel_8h.html">ci_kernel.h</a> as <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gae7a2dce885748012226e0920f292d54b">MMU_MAX_TILING_STR</a> and <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#gaf93f0ec41d2afcb2075deb315dd4af9a">MMU_MIN_TILING_STR</a>.</p>
</div>
</div>
<div class="section" id="shot-and-buffer-lifecycle">
<span id="isp-ci-shot-and-buffer-lifecycle"></span><h2>Shot and Buffer lifecycle<a class="headerlink" href="#shot-and-buffer-lifecycle" title="Permalink to this headline">¶</a></h2>
<p>This section describes the several operations that are done on a Shot, from
the creation (allocation or importation) to the destruction. A Shot contains
information about several Buffers (e.g. encoder buffer and display buffer)
but also some internal data. Both kernel and user-space store information
about Shots and Buffers in different structures.</p>
<p><strong>The distinction between SHOT and BUFFER is very important:</strong> a Buffer
represent only 1 output of the pipeline while a Shot aggregates all the
outputs. Not all the memory accessible from a Shot is a Buffer, for instance
internal memory is only part of the Shot (i.e. the user cannot choose which
internal buffer to use when triggering a shot).</p>
<p>Internal memory buffers accessible to the user are:</p>
<ul class="simple">
<li>Statistics output</li>
<li>Defective pixels output map</li>
<li>Encoder statistics output</li>
</ul>
<p>Internal memory buffers accessible only in kernel-space are:</p>
<ul class="simple">
<li>Linked list structure</li>
<li>Load structure</li>
<li>Other input buffers (Defective read map, LSH grid) that are transferred
from user to kernel before being written</li>
</ul>
<p>Importable memory buffers are all the output images:</p>
<ul class="simple">
<li>Encoder pipeline output</li>
<li>Display pipeline output</li>
<li>Data Extraction output</li>
<li>HDR extraction output if the HW version allows this format</li>
<li>RAW 2D extraction output if the HW version allows this format</li>
</ul>
<p>As shown in <a class="reference internal" href="#isp-ci-shot-elements-fig"><span>Shot elemets (simplified)</span></a> the internal only structures are
part of the Shot while the external Buffers can be dynamically attached to
it <a class="footnote-reference" href="#id33" id="id22">[2]</a>.</p>
<p>The following sections will explain the Shots and Buffer lifecycle from the
user-side perspective as an overview of the cycle and from the kernel-side
driver perspective as more in depth view of the system.</p>
<div class="figure" id="id39">
<span id="isp-ci-shot-elements-fig"></span><a class="reference internal image-reference" href="../_images/CI_Shot_Elems.png"><img alt="../_images/CI_Shot_Elems.png" src="../_images/CI_Shot_Elems.png" style="width: 302px; height: 219px;" /></a>
<p class="caption"><span class="caption-text">Shot elemets (simplified)</span></p>
</div>
<div class="section" id="shot-pool-size-and-number-of-buffers">
<span id="isp-ci-shot-pool-size-and-number-of-buffers"></span><h3>Shot pool size and number of buffers<a class="headerlink" href="#shot-pool-size-and-number-of-buffers" title="Permalink to this headline">¶</a></h3>
<p>The Shots represent the pool of simultaneous request that can be pending in
the system. That includes the number of request to the HW to keep busy
capturing while user-space processes the result. The number of buffers per
output is the number of image data circulating in the whole system.</p>
<p>The CI library allows the triggering of a capture with specific Buffers but
will always take the 1st available Shot (because the user may have
preferences on which buffer to fill but should not care if a Shot is used or
not).</p>
<p>For example let’s consider a system where a user needs 1 YUV image to give
to an encoder. Let’s imagine that the encoder requires 2 images to be able
to encode 1 image (the previous one for reference). Let’s also assume that
encoding 1 frame requires the same time as capture a frame. We also assume
that the encoder does not need any other information from the V2500 HW.</p>
<p>We need at least 4 Buffers to keep the V2500 busy at all time. However we
can reuse the Shots (we only need 2 to keep HW busy all the time):</p>
<ul class="simple">
<li>Initial stage: 2 Shots (0 and 1) and 4 Buffers (0 to 3)
(<a class="reference internal" href="#isp-ci-capture-t0-t1-fig"><span>Capture initial steps (t=0, t=1).</span></a> t=0)</li>
<li>1st capture uses Shot 0 with Buffer 0 (<a class="reference internal" href="#isp-ci-capture-t0-t1-fig"><span>Capture initial steps (t=0, t=1).</span></a> t=1)</li>
<li>2nd capture uses Shot 1 with Buffer 1; give result Buffer 0 to the
encoder; Shot 0 becomes available (<a class="reference internal" href="#isp-ci-capture-t2-t3-fig"><span>Capture running steps (t=2, t=3).</span></a> t=2).</li>
<li>3rd capture uses Shot 0 with Buffer 2; give result Buffer 1 to encoder
(reference Buffer 0); Shot 1 becomes available
(<a class="reference internal" href="#isp-ci-capture-t2-t3-fig"><span>Capture running steps (t=2, t=3).</span></a> t=3).</li>
<li>4th capture uses Shot 1 with Buffer 3; give result Buffer 2 to encoder
(reference Buffer 1); Buffer 0 becomes available; Shot 0 becomes available
(<a class="reference internal" href="#isp-ci-capture-t4-t5-fig"><span>Capture running steps (t=4, t=5).</span></a> t=4).</li>
<li>5th capture uses Shot 0 with Buffer 0; give result Buffer 3 to encoder
(reference Buffer 2); Buffer 1 becomes available; Shot 1 becomes available
(<a class="reference internal" href="#isp-ci-capture-t4-t5-fig"><span>Capture running steps (t=4, t=5).</span></a> t=5).</li>
<li>Continue until the end of sequence.</li>
</ul>
<div class="figure" id="id40">
<span id="isp-ci-capture-t0-t1-fig"></span><a class="reference internal image-reference" href="../_images/CI_Capture_t0_t1.png"><img alt="../_images/CI_Capture_t0_t1.png" src="../_images/CI_Capture_t0_t1.png" style="width: 585px; height: 283px;" /></a>
<p class="caption"><span class="caption-text">Capture initial steps (t=0, t=1).</span></p>
</div>
<div class="figure" id="id41">
<span id="isp-ci-capture-t2-t3-fig"></span><a class="reference internal image-reference" href="../_images/CI_Capture_t2_t3.png"><img alt="../_images/CI_Capture_t2_t3.png" src="../_images/CI_Capture_t2_t3.png" style="width: 585px; height: 283px;" /></a>
<p class="caption"><span class="caption-text">Capture running steps (t=2, t=3).</span></p>
</div>
<div class="figure" id="id42">
<span id="isp-ci-capture-t4-t5-fig"></span><a class="reference internal image-reference" href="../_images/CI_Capture_t4_t5.png"><img alt="../_images/CI_Capture_t4_t5.png" src="../_images/CI_Capture_t4_t5.png" style="width: 585px; height: 283px;" /></a>
<p class="caption"><span class="caption-text">Capture running steps (t=4, t=5).</span></p>
</div>
</div>
<div class="section" id="user-side-perspective">
<span id="isp-ci-shot-buffer-user-side-perspective"></span><h3>User-side perspective<a class="headerlink" href="#user-side-perspective" title="Permalink to this headline">¶</a></h3>
<p>The user-side management of Shots and Buffers is relatively basic. The
user-side driver considers Shots and Buffers as consumer would: waiting for
them to be available.</p>
<div class="section" id="storage">
<h4>Storage<a class="headerlink" href="#storage" title="Permalink to this headline">¶</a></h4>
<p>In user-side the Shots are stored as an internal structure <a class="reference external" href="../doxygen/struct_i_n_t___s_h_o_t.html">INT_SHOT</a>
(i.e. not accessible by the user of the CI library) that exposes a public
<a class="reference external" href="../doxygen/struct_c_i___s_h_o_t.html">CI_SHOT</a> containing the information that the CI user may need.</p>
<p>The Shots are stored in a list of the internal pipeline object
(<a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html">INT_PIPELINE</a>) that the user cannot see (created internally when
creating <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a>): <a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html#a30e7201f31f77f4f3c2ffeea173a6b66">INT_PIPELINE::sList_shots</a>.</p>
<p>Because the user needs the possibility to specify which Buffer is used for a
capture the Buffers are stored in a different list,
<a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html#a7b18f493490980cb4d94b6242cc15cc3">INT_PIPELINE::sList_buffers</a>, as an internal structure
<a class="reference external" href="../doxygen/struct_i_n_t___b_u_f_f_e_r.html">INT_BUFFER</a>. This list is searched when acquiring a captured frame for
all specified Buffers and the result is aggregated into an available Shot.</p>
</div>
<div class="section" id="creation-of-buffers">
<span id="isp-ci-creation-of-buffers"></span><h4>Creation of Buffers<a class="headerlink" href="#creation-of-buffers" title="Permalink to this headline">¶</a></h4>
<p>The creation is initialised from the user-side, the application either
import information using ion (e.g. <a class="reference external" href="../doxygen/ci__api_8h.html#a73cbc9a4ec455ea9a343b7cb881e88dd">CI_PipelineImportBuffer()</a>) or
using buffer allocation <a class="reference external" href="../doxygen/ci__api_8h.html#a51a5289974c9ea89dae9362ce3403748">CI_PipelineAllocateBuffer()</a>. The
<a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> object has to be registered to kernel-side for either of
these functions to work.</p>
<p>The buffer for each output has to be created separately.</p>
<p>For the creation of a buffer the user-space does the following steps:</p>
<ul class="simple">
<li>Contact the kernel-side with <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaec0faaca37818c04fa24ac2ce5b91dd2">CI_IOCTL_CREATE_BUFF</a> to receive
information about the Buffer memory. This includes the Buffer ID and size.
The result is stored in a new <a class="reference external" href="../doxygen/struct_i_n_t___b_u_f_f_e_r.html">INT_BUFFER</a>.</li>
<li>Map the buffer to user space using <code class="docutils literal"><span class="pre">mmap()</span></code> <a class="footnote-reference" href="#id34" id="id23">[3]</a></li>
<li>Add the buffer to <a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html#a7b18f493490980cb4d94b6242cc15cc3">INT_PIPELINE::sList_buffers</a> as an available
Buffer. The <a class="reference external" href="../doxygen/struct_i_n_t___b_u_f_f_e_r.html">INT_BUFFER</a> has the same ID than the one in the kernel.</li>
</ul>
<p>Buffers can be de-allocated at any-time as long as the capture is stopped.</p>
</div>
<div class="section" id="creation-of-shots">
<h4>Creation of Shots<a class="headerlink" href="#creation-of-shots" title="Permalink to this headline">¶</a></h4>
<p>Shots are allocated by pools. The size of the pool represent the number of
simultaneous frames the user wants to request at once (e.g. to use double
buffering at least 2 shots should be created).</p>
<p>For each created Shot the following steps are performed:</p>
<ul class="simple">
<li>Contact the kernel-side with <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaea204f0d6fe0a08598581ec3fcf3bbef">CI_IOCTL_PIPE_ADD</a> and receive
information about the newly created Shot&#8217;s ID</li>
<li>The Shot ID is stored into a new <a class="reference external" href="../doxygen/struct_i_n_t___s_h_o_t.html">INT_SHOT</a> and statistics and other
accessible information are mapped using <code class="docutils literal"><span class="pre">mmap()</span></code>.</li>
<li>The <a class="reference external" href="../doxygen/struct_i_n_t___b_u_f_f_e_r.html">INT_BUFFER</a> is pushed into <a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html#a30e7201f31f77f4f3c2ffeea173a6b66">INT_PIPELINE::sList_shots</a> as
available. This Shot has the same shot ID than one in the kernel-side.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Once allocated a Shot cannot be destroyed until the destruction of its
parent Pipeline object.</p>
</div>
</div>
<div class="section" id="start-the-capture">
<h4>Start the capture<a class="headerlink" href="#start-the-capture" title="Permalink to this headline">¶</a></h4>
<p>This event has no impact on the user-side storage of the Shots and Buffers.</p>
</div>
<div class="section" id="triggering-a-shot">
<h4>Triggering a Shot<a class="headerlink" href="#triggering-a-shot" title="Permalink to this headline">¶</a></h4>
<p>The Shots are queued into the HW capture list when the user side enables it. The
triggering can be blocking or non-blocking (which will be explained in the
kernel-side section). The <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> object has to be started to
perform that operation.</p>
<p>The <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> object allows the user to specify which Buffer should
be used for a particular shot (<a class="reference external" href="../doxygen/ci__pipeline_8c.html#abe5934c3cb1f092ea8b9c99feecef176">CI_PipelineTriggerSpecifiedShoot()</a>),
or simply use the first available ones (<a class="reference external" href="../doxygen/ci__api_8h.html#a7184dc54c0f349c2b906a2cb0e72e09e">CI_PipelineTriggerShoot()</a>).
It is not recommended to mix the calls (use either) as the Pipeline object
verifies if the Buffer is available or not for capture.</p>
<p>The operation from the user-side is very simple:</p>
<ul class="simple">
<li>Contact the kernel-side with <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gab086ae5d18bddb6a1aedabf6272e05a8">CI_IOCTL_CAPT_TRG</a> with Buffer ID
information for the shot.</li>
</ul>
<p>The triggering can fail for several reasons, including the fact that the
specified buffers are not available.</p>
<p>The triggering is a FIFO, and available Shots have to be acquired to access
the image they contain.</p>
</div>
<div class="section" id="acquiring-a-shot">
<h4>Acquiring a Shot<a class="headerlink" href="#acquiring-a-shot" title="Permalink to this headline">¶</a></h4>
<p>When the user-side needs a Shot it has to query for an available one. The
user can choose for the acquisition to be waiting for an available shot or
returning with an error when none are found. Note that the kernel-side only
waits for a limited amount of time before returning and error even in the
former case to avoid infinite wait if the HW is stuck. The process is:</p>
<ul class="simple">
<li>Contact the kernel side with <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaa4119504e9291e286a0277a09a9dc045">CI_IOCTL_CAPT_BAQ</a> which will return a
Shot ID and Buffer IDs to an available capture.</li>
<li>The Shot ID is searched in the list of Shots
(<a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html#a30e7201f31f77f4f3c2ffeea173a6b66">INT_PIPELINE::sList_shots</a>). The Shot is tagged as acquired and
cannot be used by a trigger call until released.</li>
<li>The Buffer IDs are searched in the list of Buffers
(<a class="reference external" href="../doxygen/struct_i_n_t___p_i_p_e_l_i_n_e.html#a7b18f493490980cb4d94b6242cc15cc3">INT_PIPELINE::sList_buffers</a>) and attached to the found Shot. They
are tagged as acquired and cannot be used by a trigger call until released.</li>
<li>The public part of the Shot (<a class="reference external" href="../doxygen/struct_c_i___s_h_o_t.html">CI_SHOT</a>) is returned to the user.</li>
</ul>
<p>The user can now use the memory and must release the shot when it is no long required
to free up its associated Buffers.</p>
</div>
<div class="section" id="releasing-an-acquired-shot">
<h4>Releasing an acquired Shot<a class="headerlink" href="#releasing-an-acquired-shot" title="Permalink to this headline">¶</a></h4>
<p>The user-side acknowledges that a Shot is now available for another capture
following the operations:</p>
<ul class="simple">
<li>Contact the kernel-side with <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga4e41176a77645efd7003339158ad24e7">CI_IOCTL_CAPT_BRE</a> to signal which Shot
and Buffer should now be considered available again</li>
<li><a class="reference external" href="../doxygen/struct_i_n_t___b_u_f_f_e_r.html">INT_BUFFER</a> and the <a class="reference external" href="../doxygen/struct_i_n_t___s_h_o_t.html">INT_SHOT</a> are tagged as available again</li>
</ul>
</div>
<div class="section" id="destruction">
<h4>Destruction<a class="headerlink" href="#destruction" title="Permalink to this headline">¶</a></h4>
<p>The Shots and Buffers are destroyed when the <a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> object that
owns them is destroyed. They cannot be passed to another object. Imported
Buffers can of course be re-imported in other objects. At destruction time
both Shot and Buffer lists are cleared.</p>
<ul class="simple">
<li>Each Buffer is unmapped</li>
<li>Each Shot has its internal memory unmapped</li>
<li>Contact the kernel-side with <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga032f7f94cc29b58266d6a3cf7b8dad23">CI_IOCTL_PIPE_DEL</a> to signal that the
equivalent object should be destroyed</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is also possible to de-register a Buffer using
<a class="reference external" href="../doxygen/ci__api_8h.html#a0ad9a3c911ac85e4fb8149abbcea123c">CI_PipelineDeregisterBuffer()</a> but the capture cannot be running
for that to occur.</p>
</div>
</div>
</div>
<div class="section" id="kernel-side-perspective">
<span id="isp-ci-shot-buffer-kernel-side-perspective"></span><h3>Kernel-side perspective<a class="headerlink" href="#kernel-side-perspective" title="Permalink to this headline">¶</a></h3>
<p>The kernel-side is contacted by the user-side in regards of Shot and Buffer
management. It has to deal with several duties that the user-side does not
have to know about:</p>
<ul class="simple">
<li>Allocation size</li>
<li>Device MMU handling</li>
<li>HW waiting list</li>
</ul>
<div class="section" id="id24">
<h4>Storage<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>The Shots are stored in the kernel-side as <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a>, which
contains user side information (<a class="reference external" href="../doxygen/struct_c_i___s_h_o_t.html">CI_SHOT</a>), internal memory available
to user-space (e.g. statistics) and internal memory needed for HW
management. Some Buffers can be attached as <a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a>. Each Shot
is stored in a unique <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html">KRN_CI_PIPELINE</a> object. A Shot also has a state
which specifies the potential usage of the memory.</p>
<p>The Buffers that can be specified by the user are stored as pointers of
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a> in a <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a>.</p>
<p>A <a class="reference external" href="../doxygen/struct_k_r_n___c_i___b_u_f_f_e_r.html">KRN_CI_BUFFER</a> contains the information needed to handle the memory
with the HW.</p>
<p>The <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html">KRN_CI_PIPELINE</a> has several lists where Shots are stored (see
<a class="reference internal" href="#isp-ci-shot-states-fig"><span>KRN_CI_SHOT states (kernel-side).</span></a> or <a class="reference external" href="../doxygen/group___k_r_n___c_i___a_p_i.html#ga1ced0a7a4f29d49f0004bdffe7ead8ec">KRN_CI_SHOT_eSTATUS</a>):</p>
<ul>
<li><p class="first"><a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a2113acf4d06042dfaed887a1ee8fa300">KRN_CI_PIPELINE::sList_available</a> where Shots have the
<code class="docutils literal"><span class="pre">CI_SHOT_AVAILABLE</span></code> state.</p>
<p>The Shots stored in there can be pushed into the HW queue for capture.
They will be marked as pending when a capture is triggered.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a34a3be2035abddee44acf714e6f65d0f">KRN_CI_PIPELINE::sList_pending</a> where Shots have the
<code class="docutils literal"><span class="pre">CI_SHOT_PENDING</span></code> state.</p>
<p>The Shots stored there are waiting for the HW to process them. They are
added when a capture is triggered. The interrupt-handler removes the shot
from the list and marks them as processed when the HW completed the capture.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a6b167f2dcb94b1ce30c12b2774bed463">KRN_CI_PIPELINE::sList_processed</a> where Shots have the
<code class="docutils literal"><span class="pre">CI_SHOT_PROCESSED</span></code> state.</p>
<p>The Shots stored there were processed by the HW and are waiting to be
acquired by user-space.</p>
</li>
<li><p class="first"><a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a9e8d3c54fa2001d745c3c11196878afd">KRN_CI_PIPELINE::sList_sent</a> where Shots have the
<code class="docutils literal"><span class="pre">CI_SHOT_SENT</span></code> state.</p>
<p>The Shots stored there were acquired by the user-side and will be pushed
back into the available list when released.</p>
</li>
</ul>
<div class="figure" id="id43">
<span id="isp-ci-shot-states-fig"></span><a class="reference internal image-reference" href="../_images/CI_Shot_States.png"><img alt="../_images/CI_Shot_States.png" src="../_images/CI_Shot_States.png" style="width: 443px; height: 193px;" /></a>
<p class="caption"><span class="caption-text">KRN_CI_SHOT states (kernel-side).</span></p>
</div>
</div>
<div class="section" id="id25">
<h4>Creation of Shots<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>In the kernel-side the creation is done in 2 actions from the user-side</p>
<ol class="arabic simple">
<li>creation of the Shot (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaea204f0d6fe0a08598581ec3fcf3bbef">CI_IOCTL_PIPE_ADD</a>)</li>
<li>mapping of the memory to user-side (<code class="docutils literal"><span class="pre">mmap()</span></code> called)</li>
</ol>
<div class="section" id="ci-ioctl-pipe-add-event-received">
<h5>CI_IOCTL_PIPE_ADD event received<a class="headerlink" href="#ci-ioctl-pipe-add-event-received" title="Permalink to this headline">¶</a></h5>
<p>The kernel-side considers that a Shot should be created when the user-side
notifies it. The user-side may provide buffers to import later on. The
<a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> from user-side has to be registered in the kernel-space
for the addition to occur.</p>
<ul class="simple">
<li>The various buffer sizes of the internal elements are determined from the
configuration.</li>
<li>The physical memory is allocated and virtual memory reserved for the
internal buffers</li>
<li>A unique identifier is created for each internal buffer accessible in
user-space. This is returned to user-space to allow them to map them.</li>
<li>A new <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a> object is created and added to the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___c_o_n_n_e_c_t_i_o_n.html#a063ddb65a01eced047debb9458875624">KRN_CI_CONNECTION::sList_unmappedShots</a> list until it is mapped in
user-space.</li>
</ul>
</div>
<div class="section" id="mmap-called">
<h5>mmap() called<a class="headerlink" href="#mmap-called" title="Permalink to this headline">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">mmap()</span></code> system call should be called for every Shot’s internal buffer
that the user-space has an ID for. For each call the kernel-side will:</p>
<ul class="simple">
<li>Search for the Shot that contains a buffer with the given ID in
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___c_o_n_n_e_c_t_i_o_n.html#a063ddb65a01eced047debb9458875624">KRN_CI_CONNECTION::sList_unmappedShots</a></li>
<li>Map the memory to user-side of the given internal buffer (e.g. statistics)</li>
<li>If all the internal elements for the Shot have been mapped the Shot will
be removed from the <a class="reference external" href="../doxygen/struct_k_r_n___c_i___c_o_n_n_e_c_t_i_o_n.html#a063ddb65a01eced047debb9458875624">KRN_CI_CONNECTION::sList_unmappedShots</a> list and
added to the <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a2113acf4d06042dfaed887a1ee8fa300">KRN_CI_PIPELINE::sList_available</a> one.</li>
</ul>
</div>
</div>
<div class="section" id="id26">
<h4>Creation of Buffers<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p>In the kernel-side the creation is done in 2 actions from the user-side</p>
<ol class="arabic simple">
<li>creation of the Shot (<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaec0faaca37818c04fa24ac2ce5b91dd2">CI_IOCTL_CREATE_BUFF</a>)</li>
<li>mapping of the memory to user-side (<code class="docutils literal"><span class="pre">mmap()</span></code> called)</li>
</ol>
<div class="section" id="ci-ioctl-create-buff-event-received">
<h5>CI_IOCTL_CREATE_BUFF event received<a class="headerlink" href="#ci-ioctl-create-buff-event-received" title="Permalink to this headline">¶</a></h5>
<p>The kernel-side has 2 use cases when this even is received: either the
buffer should be allocated or imported. For both cases the
<a class="reference external" href="../doxygen/struct_c_i___p_i_p_e_l_i_n_e.html">CI_PIPELINE</a> from user-side has to be registered in the kernel-space
for the addition to occur.</p>
<ul class="simple">
<li>Compute the estimated size of the buffer using <a class="reference external" href="../doxygen/ci__alloc__info_8h.html">ci_alloc_info.h</a>
functions and the known size from the IIF setup.</li>
<li>Reserve the virtual memory if using the MMU (tiling may affect that and
make it bigger than the actual physical memory allocation is for the 1st
address alignment it needs).</li>
<li>Allocate or import the physical memory for the buffer (and verify that it
is big enough when importing).</li>
<li>Compute a unique identifier for the Buffer that will be returned to
user-space for mapping</li>
<li>Push the Buffer into the <a class="reference external" href="../doxygen/struct_k_r_n___c_i___c_o_n_n_e_c_t_i_o_n.html#a3b72524e214b3a85e134d6f9f11e3ee4">KRN_CI_CONNECTION::sList_unmappedBuffers</a>
until user-space calls <code class="docutils literal"><span class="pre">mmap()</span></code>.</li>
</ul>
</div>
<div class="section" id="id27">
<h5>mmap() called<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h5>
<p>When <code class="docutils literal"><span class="pre">mmap()</span></code> is called the Buffer is considered available for captures
and added to <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#afb4dd7e763740f9af8d0bf41f922ed40">KRN_CI_PIPELINE::sList_availableBuffers</a>.</p>
</div>
</div>
<div class="section" id="id28">
<h4>Start the capture<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<p>When the <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga757a34ff2f2d66036485de944697f47a">CI_IOCTL_CAPT_STA</a> event is received the kernel-side has to
reserve the HW and configure the device MMU. Each allocated Buffer will be
mapped to the device MMU at this point.</p>
</div>
<div class="section" id="id29">
<h4>Triggering a Shot<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>When the capture is started the kernel-side will use the
<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gab086ae5d18bddb6a1aedabf6272e05a8">CI_IOCTL_CAPT_TRG</a> event to add elements into the HW processing FIFO
using the following steps:</p>
<ul class="simple">
<li>Get the 1st <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a> from the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a2113acf4d06042dfaed887a1ee8fa300">KRN_CI_PIPELINE::sList_available</a>. This may be a blocking action.</li>
<li>Searching the list of Buffers
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#afb4dd7e763740f9af8d0bf41f922ed40">KRN_CI_PIPELINE::sList_availableBuffers</a> for the specified buffers and
remove them.</li>
<li>Attach the found Buffers to the retrieved Shot</li>
<li>Prepare the internal memory with the correct memory. This means updating
the linked list addresses and load structure from the configuration.</li>
<li>Add the Shot to the back of the pending list
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a34a3be2035abddee44acf714e6f65d0f">KRN_CI_PIPELINE::sList_pending</a></li>
<li>Submit the capture the HW processing FIFO</li>
</ul>
</div>
<div class="section" id="hw-interrupt-signal-capture-is-over">
<h4>HW interrupt signal: capture is over<a class="headerlink" href="#hw-interrupt-signal-capture-is-over" title="Permalink to this headline">¶</a></h4>
<p>When the frame is processed the HW emits a <code class="docutils literal"><span class="pre">FRAME_DONE_ALL</span></code> interrupt
which the kernel-side will catch and do:</p>
<ul class="simple">
<li>Remove the 1st <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a> from the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a34a3be2035abddee44acf714e6f65d0f">KRN_CI_PIPELINE::sList_pending</a>.</li>
<li>Add the Shot to the <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a6b167f2dcb94b1ce30c12b2774bed463">KRN_CI_PIPELINE::sList_processed</a>.</li>
</ul>
</div>
<div class="section" id="id30">
<h4>Acquiring a Shot<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<p>On reception of <a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#gaa4119504e9291e286a0277a09a9dc045">CI_IOCTL_CAPT_BAQ</a> the kernel-side will:</p>
<ul class="simple">
<li>Get the 1st <a class="reference external" href="../doxygen/struct_k_r_n___c_i___s_h_o_t.html">KRN_CI_SHOT</a> from the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a6b167f2dcb94b1ce30c12b2774bed463">KRN_CI_PIPELINE::sList_processed</a>. This may be a blocking action.</li>
<li>Push the acquired Shot to the back of the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a9e8d3c54fa2001d745c3c11196878afd">KRN_CI_PIPELINE::sList_sent</a> list.</li>
<li>Update the host memory (CPU side) for all device-memory to ensure
user-space has up-to-date memory</li>
<li>Return the Shot ID and Buffer IDs to user-side</li>
</ul>
</div>
<div class="section" id="id31">
<h4>Releasing an acquired Shot<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<p>Once the user-side is done with the memory it should emit a
<a class="reference external" href="../doxygen/group___c_i___i_o_c_t_l.html#ga4e41176a77645efd7003339158ad24e7">CI_IOCTL_CAPT_BRE</a> event. The kernel-side will process it as:</p>
<ul class="simple">
<li>Searching for the given Shot ID into the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a9e8d3c54fa2001d745c3c11196878afd">KRN_CI_PIPELINE::sList_sent</a> list.</li>
<li>Push back all the available Buffers into the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#afb4dd7e763740f9af8d0bf41f922ed40">KRN_CI_PIPELINE::sList_availableBuffers</a></li>
<li>Remove the Shot from the sent list and add it into the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a2113acf4d06042dfaed887a1ee8fa300">KRN_CI_PIPELINE::sList_available</a> one.</li>
</ul>
</div>
<div class="section" id="deregister-a-buffer">
<h4>Deregister a Buffer<a class="headerlink" href="#deregister-a-buffer" title="Permalink to this headline">¶</a></h4>
<p>It is possible to de-register a Buffer if the Pipeline is not doing a
capture. In that the Buffer will:</p>
<ul class="simple">
<li>Be removed from the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#afb4dd7e763740f9af8d0bf41f922ed40">KRN_CI_PIPELINE::sList_availableBuffers</a>.</li>
<li>Free the allocated device and virtual memory (or release the device memory
if imported).</li>
</ul>
</div>
<div class="section" id="destruction-of-the-shots">
<h4>Destruction of the Shots<a class="headerlink" href="#destruction-of-the-shots" title="Permalink to this headline">¶</a></h4>
<p>On destruction of the <a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html">KRN_CI_PIPELINE</a> object the various Shots
associated with it will be cleared, that simply means that each Shot
internal buffer:</p>
<ul class="simple">
<li>Free the allocated device and virtual memory</li>
</ul>
</div>
<div class="section" id="blocking-and-non-blocking-calls">
<span id="isp-ci-shot-buffer-blocking"></span><h4>Blocking and non-blocking calls<a class="headerlink" href="#blocking-and-non-blocking-calls" title="Permalink to this headline">¶</a></h4>
<p>The 2 lists that the driver has to wait on in the kernel-side</p>
<ul class="simple">
<li><a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a2113acf4d06042dfaed887a1ee8fa300">KRN_CI_PIPELINE::sList_available</a> when triggering a shoot (waiting
for an available Shot and its internal structures).</li>
<li><a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a6b167f2dcb94b1ce30c12b2774bed463">KRN_CI_PIPELINE::sList_processed</a> when acquiring a captured Shot
(waiting for HW to signal a shot is available).</li>
</ul>
<p>To allow waiting to occur without having to busily check if any element was
added to the processed list the kernel-side driver has a semaphore
incremented every-time an interrupt is handled successfully
(<a class="reference external" href="../doxygen/struct_k_r_n___c_i___p_i_p_e_l_i_n_e.html#a8790e2a1458dec8ec2a874dedb4ce564">KRN_CI_PIPELINE::sProcessedSem</a>).</p>
<p>The available list does not have an associate semaphore and the triggering
will fail if no available shots are pending (because they are released by the
user therefore waiting would result in a lockup). However the driver has to
ensure that the HW FIFO list is not full and a semaphore is used for that
(so the user-side can be kept waiting pushing a frame for capture until the
HW FIFO has an available slot). This is implemented with the
<a class="reference external" href="../doxygen/struct_k_r_n___c_i___d_r_i_v_e_r.html#a5a0388a867306accb3db77fec7ddc12f">KRN_CI_DRIVER::aListQueue</a> semaphore, incremented when handling
interrupts as well.</p>
<p>Waiting on the semaphore is never for an infinite amount of time: a
compilation time value defines the maximum amount of time to wait for
(<code class="docutils literal"><span class="pre">CI_SEM_WAIT</span></code> in <code class="docutils literal"><span class="pre">kernel_src/ci_init_km.c</span></code>). At the time of writing the
value is 5000ms, this value should be more than enough for a frame to be
processed by the HW using the external data generator on limited bandwidth
system. A timeout on acquiring a frame can be considered as a HW or sensor
lockup or failure. The actual waiting time can be changed at insmod time
(see <a class="reference internal" href="../getting_started.html#isp-gsg-insmod-options"><span>Getting Started Guide</span></a>).</p>
<hr class="docutils" />
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[1]</a></td><td>The MMU HW is designed for the decoder that has a front end and back
end, resulting in only 2 of the 4 MMU directories to be used at once (and
the decoder driver has to choose which one at given points of the decoding).
This limitation may change from a version of the MMU HW to another.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[2]</a></td><td>In C the distinction is a pointer for dynamically attached objects
while the other Buffers are part of the Shot structure.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[3]</a></td><td>For the moment <code class="docutils literal"><span class="pre">mmap()</span></code> is used even when using ION allocator,
which may be changed to use <code class="docutils literal"><span class="pre">gralloc</span></code> to retrieve the user-side memory in
the future.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Capture Interface</a><ul>
<li><a class="reference internal" href="#design-choices">Design Choices</a><ul>
<li><a class="reference internal" href="#naming-convention">Naming convention</a></li>
<li><a class="reference internal" href="#folder-organisation">Folder organisation</a></li>
<li><a class="reference internal" href="#libraries-and-namespaces">Libraries and namespaces</a></li>
<li><a class="reference internal" href="#fake-and-real-driver">Fake and Real driver</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations">Limitations</a><ul>
<li><a class="reference internal" href="#isp-ci-identifiers">Identifiers</a></li>
<li><a class="reference internal" href="#linux-kernel-trouble">Linux Kernel Trouble</a><ul>
<li><a class="reference internal" href="#memory-band-management-genalloc">Memory band management (<code class="docutils literal"><span class="pre">genalloc</span></code>)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#hw-modules-and-resources">HW Modules and resources</a><ul>
<li><a class="reference internal" href="#hw-resources">HW Resources</a></li>
<li><a class="reference internal" href="#line-store">Line-store</a><ul>
<li><a class="reference internal" href="#hw-knowledge">HW Knowledge</a></li>
<li><a class="reference internal" href="#hw-context-and-ci-pipeline-object">HW Context and <code class="docutils literal"><span class="pre">CI_PIPELINE</span></code> object</a></li>
<li><a class="reference internal" href="#hw-gasket-and-ci-gasket-object">HW Gasket and <code class="docutils literal"><span class="pre">CI_GASKET</span></code> object</a></li>
<li><a class="reference internal" href="#hw-internal-data-generator-and-ci-datagen-object">HW Internal Data Generator and <code class="docutils literal"><span class="pre">CI_DATAGEN</span></code> object</a></li>
<li><a class="reference internal" href="#hw-external-data-generator-and-dg-camera-object">HW External Data Generator and <code class="docutils literal"><span class="pre">DG_CAMERA</span></code> object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gamma-correction">Gamma Correction</a><ul>
<li><a class="reference internal" href="#isp-ci-gamma-hw-knowledge">HW Knowledge</a></li>
<li><a class="reference internal" href="#driver-limitations">Driver Limitations</a></li>
<li><a class="reference internal" href="#gamma-look-up-table-customisation">Gamma Look-Up table customisation</a><ul>
<li><a class="reference internal" href="#change-the-default-curve">Change the default curve</a></li>
<li><a class="reference internal" href="#add-other-curves">Add other curves</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deshading-grid-lens-shading">Deshading Grid (Lens shading)</a><ul>
<li><a class="reference internal" href="#lsh-grid-from-user-space">LSH grid from user-space</a></li>
<li><a class="reference internal" href="#lsh-grid-from-kernel-space">LSH grid from kernel-space</a><ul>
<li><a class="reference internal" href="#lsh-grid-buffer-creation">LSH grid: buffer creation</a></li>
<li><a class="reference internal" href="#which-matrix-is-currently-in-use">Which matrix is currently in use</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#output-formats-and-sizes">Output Formats and sizes</a><ul>
<li><a class="reference internal" href="#encoder-pipeline-formats-yuv">Encoder pipeline formats (YUV)</a><ul>
<li><a class="reference internal" href="#register-setup">Register setup</a></li>
<li><a class="reference internal" href="#ci-setup">CI setup</a></li>
<li><a class="reference internal" href="#mc-setup">MC setup</a></li>
<li><a class="reference internal" href="#enabling-tiling">Enabling Tiling</a></li>
<li><a class="reference internal" href="#additional-yuv-formats">Additional YUV formats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#display-pipeline-formats-rgb">Display pipeline formats (RGB)</a><ul>
<li><a class="reference internal" href="#id2">Register setup</a></li>
<li><a class="reference internal" href="#id3">CI setup</a></li>
<li><a class="reference internal" href="#id4">MC setup</a></li>
<li><a class="reference internal" href="#id5">Enabling Tiling</a></li>
<li><a class="reference internal" href="#additional-rgb-formats">Additional RGB formats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-extraction-formats-bayer">Data Extraction formats (Bayer)</a><ul>
<li><a class="reference internal" href="#id6">Register setup</a></li>
<li><a class="reference internal" href="#id7">CI setup</a></li>
<li><a class="reference internal" href="#id8">MC setup</a></li>
<li><a class="reference internal" href="#id9">Enabling Tiling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hdr-extraction">HDR Extraction</a><ul>
<li><a class="reference internal" href="#id10">Register setup</a></li>
<li><a class="reference internal" href="#id11">CI setup</a></li>
<li><a class="reference internal" href="#id12">MC setup</a></li>
<li><a class="reference internal" href="#id13">Enabling Tiling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#raw-2d-extraction-tiff">Raw 2D Extraction (TIFF)</a><ul>
<li><a class="reference internal" href="#id14">Register setup</a></li>
<li><a class="reference internal" href="#id15">CI setup</a></li>
<li><a class="reference internal" href="#id16">MC setup</a></li>
<li><a class="reference internal" href="#id17">Enabling Tiling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#different-output-size">Different Output Size</a></li>
<li><a class="reference internal" href="#different-memory-layout">Different memory layout</a></li>
<li><a class="reference internal" href="#notes-on-tiling">Notes on Tiling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#v2500-cache-behaviour">V2500 Cache behaviour</a><ul>
<li><a class="reference internal" href="#compilation-choice">Compilation choice</a></li>
</ul>
</li>
<li><a class="reference internal" href="#suspend-and-resume-calls">Suspend and Resume calls</a></li>
</ul>
</li>
<li><a class="reference internal" href="#user-kernel-interactions">User/Kernel interactions</a><ul>
<li><a class="reference internal" href="#fake-implementation">Fake Implementation</a></li>
<li><a class="reference internal" href="#interactions">Interactions</a><ul>
<li><a class="reference internal" href="#direct-interaction">Direct interaction</a></li>
<li><a class="reference internal" href="#indirect-interaction">Indirect interaction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#img-errors-and-errno-values">IMG Errors and Errno values</a></li>
<li><a class="reference internal" href="#debug-functions-fake-driver">Debug Functions (fake driver)</a><ul>
<li><a class="reference internal" href="#register-dumping">Register Dumping</a><ul>
<li><a class="reference internal" href="#register-dumping-file-format">Register dumping file format</a></li>
<li><a class="reference internal" href="#register-dumping-options">Register dumping options</a></li>
<li><a class="reference internal" href="#register-override">Register override</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#debugfs-real-driver">DebugFS (real driver)</a><ul>
<li><a class="reference internal" href="#general-entries">General entries</a></li>
<li><a class="reference internal" href="#context-entries-is-context-number">Context entries (# is context number)</a></li>
<li><a class="reference internal" href="#external-data-generator-entries-is-datagen-number">External Data-generator entries (# is datagen number)</a></li>
<li><a class="reference internal" href="#internal-data-generator-entries-is-internal-dg-number">Internal Data-generator entries (# is internal DG number)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#register-access-for-debugging-purposes">Register access for debugging purposes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interrupt-management">Interrupt Management</a><ul>
<li><a class="reference internal" href="#request-and-release-of-the-interrupt-line">Request and release of the interrupt line</a></li>
<li><a class="reference internal" href="#configured-interrupts">Configured interrupts</a></li>
<li><a class="reference internal" href="#top-half-interrupt-context">Top Half - Interrupt context</a><ul>
<li><a class="reference internal" href="#contexts">Contexts</a></li>
<li><a class="reference internal" href="#internal-data-generator">Internal Data Generator</a></li>
<li><a class="reference internal" href="#gasket">Gasket</a></li>
<li><a class="reference internal" href="#mmu">MMU</a></li>
<li><a class="reference internal" href="#external-data-generator">External Data Generator</a></li>
<li><a class="reference internal" href="#system-device-clear">System Device clear</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bottom-half-thread-context">Bottom Half - Thread context</a><ul>
<li><a class="reference internal" href="#id18">Contexts</a></li>
<li><a class="reference internal" href="#id19">Internal Data Generator</a></li>
<li><a class="reference internal" href="#id20">External Data Generator</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#memory-mapping-unit-mmu">Memory Mapping Unit (MMU)</a><ul>
<li><a class="reference internal" href="#mmu-size">MMU size</a></li>
<li><a class="reference internal" href="#mmu-requestors">MMU Requestors</a></li>
<li><a class="reference internal" href="#mmu-interrupts">MMU Interrupts</a></li>
<li><a class="reference internal" href="#virtual-address-management-and-heaps">Virtual Address management and heaps</a><ul>
<li><a class="reference internal" href="#hardware-heap-management">Hardware heap management</a></li>
<li><a class="reference internal" href="#software-heap-management">Software heap management</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mmu-cache-management-and-flushing">MMU Cache management and flushing</a></li>
<li><a class="reference internal" href="#mmu-tiling-information">MMU Tiling information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shot-and-buffer-lifecycle">Shot and Buffer lifecycle</a><ul>
<li><a class="reference internal" href="#shot-pool-size-and-number-of-buffers">Shot pool size and number of buffers</a></li>
<li><a class="reference internal" href="#user-side-perspective">User-side perspective</a><ul>
<li><a class="reference internal" href="#storage">Storage</a></li>
<li><a class="reference internal" href="#creation-of-buffers">Creation of Buffers</a></li>
<li><a class="reference internal" href="#creation-of-shots">Creation of Shots</a></li>
<li><a class="reference internal" href="#start-the-capture">Start the capture</a></li>
<li><a class="reference internal" href="#triggering-a-shot">Triggering a Shot</a></li>
<li><a class="reference internal" href="#acquiring-a-shot">Acquiring a Shot</a></li>
<li><a class="reference internal" href="#releasing-an-acquired-shot">Releasing an acquired Shot</a></li>
<li><a class="reference internal" href="#destruction">Destruction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernel-side-perspective">Kernel-side perspective</a><ul>
<li><a class="reference internal" href="#id24">Storage</a></li>
<li><a class="reference internal" href="#id25">Creation of Shots</a><ul>
<li><a class="reference internal" href="#ci-ioctl-pipe-add-event-received">CI_IOCTL_PIPE_ADD event received</a></li>
<li><a class="reference internal" href="#mmap-called">mmap() called</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id26">Creation of Buffers</a><ul>
<li><a class="reference internal" href="#ci-ioctl-create-buff-event-received">CI_IOCTL_CREATE_BUFF event received</a></li>
<li><a class="reference internal" href="#id27">mmap() called</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id28">Start the capture</a></li>
<li><a class="reference internal" href="#id29">Triggering a Shot</a></li>
<li><a class="reference internal" href="#hw-interrupt-signal-capture-is-over">HW interrupt signal: capture is over</a></li>
<li><a class="reference internal" href="#id30">Acquiring a Shot</a></li>
<li><a class="reference internal" href="#id31">Releasing an acquired Shot</a></li>
<li><a class="reference internal" href="#deregister-a-buffer">Deregister a Buffer</a></li>
<li><a class="reference internal" href="#destruction-of-the-shots">Destruction of the Shots</a></li>
<li><a class="reference internal" href="#blocking-and-non-blocking-calls">Blocking and non-blocking calls</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../tuning/user_tuning_guide.html"
                        title="previous chapter">User Tuning Guide</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../ispc/ispc_library.html"
                        title="next chapter">ISP Control Library</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
        &copy; Imagination Technologies
    - Strictly Confidential - External
    <br>
     Built on Fri, 05 Aug 2016 13:03:49
    - Revision: <a href="#">4173926</a>
    - <a href="../index/../_pdf/manual.pdf">Printable version</a>
</div>

<!-- Embed tables in a scroller-div -->
<script type="text/javascript">
    $( "table.docutils" ).wrap( "<div class='docutils-scroller'></div>" );
</script>
<!-- End Embed tables in a scroller-div -->

<!-- Back-to-top -->
<a href="#" class="back-to-top">&#8593; TOP</a>
<script>            
    jQuery(document).ready(function() {
    var offset = 220;
        var duration = 500;
        jQuery(window).scroll(function() {
            if (jQuery(this).scrollTop() > offset) {
                jQuery('.back-to-top').fadeIn(duration);
            } else {
                jQuery('.back-to-top').fadeOut(duration);
            }
        });

        jQuery('.back-to-top').click(function(event) {
            event.preventDefault();
            jQuery('html, body').animate({scrollTop: 0}, duration);
            return false;
        })
    });
</script>
<!-- End Back-to-top -->
  </body>
</html>