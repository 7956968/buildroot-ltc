<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ISP DDK: CI Kernel tools (SYS_)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="open-sans-font.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="img.ico">
</head>
<body>
<div id="HeaderContainer">
    <div id="Header">
        <div id="HeaderContent">
            <div id="HeaderLogo">
                <a href="../../index.html"><img src="doc-logo.png" /></a>
            </div>
            <div id="ProjectName">
                ISP DDK
            </div>
        </div>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div id="MSearchBoxContainer">
          <img id="MSearchSelect" src="search.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
              <img id="MSearchCloseImg" border="0" src="search/close.png" alt="">
          </a>
          </div>
        </div>
      <div class="clearer"></div>
    </div>
</div>
<div id="NavContainer">
<nav>
    <ul>
        <li><a href="../index.html">Documents</a></li>
        <li id="NavCurrent"><a href="index.html">Source</a>
        <ul>
          <li><a href="pages.html">Related pages</a></li>
          <li><a href="modules.html">Modules</a></li>
          <li><a href="namespaces.html">Namespaces</a></li>
          <li><a href="annotated.html">Data structures</a></li>
          <li><a href="files.html">Files</a></li>
        </ul>
        </li>
    </ul>
</nav>
<div class="clearer"></div>
</div>
<div id="Content">
<div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">CI Kernel tools (SYS_)<div class="ingroups"><a class="el" href="group___k_r_n___c_i___a_p_i.html">Capture Interface: kernel-side driver documentation</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Kernel-side tools.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the information the driver needs about a device.  <a href="struct_s_y_s___d_e_v_i_c_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1fc149801e296f00c0989cf4f0e859c3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga1fc149801e296f00c0989cf4f0e859c3">SYS_MEM</a></td></tr>
<tr class="separator:ga1fc149801e296f00c0989cf4f0e859c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga91341ae6fc329f6dc28a12b90729ba4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga91341ae6fc329f6dc28a12b90729ba4e">SYS_MEM_UPD</a> { <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gga91341ae6fc329f6dc28a12b90729ba4eaf644bb7bcb359670f109afdbfd3aa0d9">SYS_MEM_UPD_HOST</a> = 0, 
<a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gga91341ae6fc329f6dc28a12b90729ba4ea339b8758444e609936891e4f9c6edb12">SYS_MEM_UPD_DEV</a>
 }</td></tr>
<tr class="separator:ga91341ae6fc329f6dc28a12b90729ba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Device abstraction</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp96d6f681672fb7c56fd81ec4354b3fbb"></a>Basic information about a device (abstracted so that it can be implemented for different systems, e.g. for CSIM or PCI FPGA board). </p>
</td></tr>
<tr class="memitem:ga817c9065bead40cb1a3a1e965ab3b2a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="sys__device_8h.html#a33561b7274066c2fe0a180a2ae633f5c">irq_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga817c9065bead40cb1a3a1e965ab3b2a3">SYS_IRQ_HANDLER</a></td></tr>
<tr class="separator:ga817c9065bead40cb1a3a1e965ab3b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5844a2a08494e94ba6566f69139ca3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga7a5844a2a08494e94ba6566f69139ca3">SYS_DEVICE</a></td></tr>
<tr class="memdesc:ga7a5844a2a08494e94ba6566f69139ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the information the driver needs about a device.  <a href="#ga7a5844a2a08494e94ba6566f69139ca3">More...</a><br/></td></tr>
<tr class="separator:ga7a5844a2a08494e94ba6566f69139ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc8f0ef3328a61819150907e0f4b8cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gadcc8f0ef3328a61819150907e0f4b8cb">SYS_DevRegister</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice)</td></tr>
<tr class="separator:gadcc8f0ef3328a61819150907e0f4b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d60e5f2e6efba3b19815af8a1de1995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga1d60e5f2e6efba3b19815af8a1de1995">SYS_DevDeregister</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice)</td></tr>
<tr class="separator:ga1d60e5f2e6efba3b19815af8a1de1995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6bb33f15beb4bea67667c7556885e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga4d6bb33f15beb4bea67667c7556885e2">SYS_DevRemove</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice)</td></tr>
<tr class="memdesc:ga4d6bb33f15beb4bea67667c7556885e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the kernel module is removed.  <a href="#ga4d6bb33f15beb4bea67667c7556885e2">More...</a><br/></td></tr>
<tr class="separator:ga4d6bb33f15beb4bea67667c7556885e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0743d654f5183789aca5ad04a6449db3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga0743d654f5183789aca5ad04a6449db3">SYS_DevClearInterrupts</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice)</td></tr>
<tr class="memdesc:ga0743d654f5183789aca5ad04a6449db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement that function if the device needs to clear more registers than the felix ones when receiving an interrupt.  <a href="#ga0743d654f5183789aca5ad04a6449db3">More...</a><br/></td></tr>
<tr class="separator:ga0743d654f5183789aca5ad04a6449db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd66adf1947f3950f4c7b5360e6f7740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gadd66adf1947f3950f4c7b5360e6f7740">SYS_DevRequestIRQ</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice, const char *pszName)</td></tr>
<tr class="memdesc:gadd66adf1947f3950f4c7b5360e6f7740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the IRQ associated with the given device.  <a href="#gadd66adf1947f3950f4c7b5360e6f7740">More...</a><br/></td></tr>
<tr class="separator:gadd66adf1947f3950f4c7b5360e6f7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdbc14a65db2afc6a6343e4c69dd4427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gacdbc14a65db2afc6a6343e4c69dd4427">SYS_DevFreeIRQ</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice)</td></tr>
<tr class="memdesc:gacdbc14a65db2afc6a6343e4c69dd4427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an aquired interrupt (if not acquired then nothing happens)  <a href="#gacdbc14a65db2afc6a6343e4c69dd4427">More...</a><br/></td></tr>
<tr class="separator:gacdbc14a65db2afc6a6343e4c69dd4427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220858d2448c195cfcaca06516746db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga220858d2448c195cfcaca06516746db9">SYS_DevPowerControl</a> (<a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *pDevice, <a class="el" href="img__types_8h.html#ad54d51a0bf32d3d4f88806da34198b79">IMG_BOOL8</a> bDeviceActive)</td></tr>
<tr class="memdesc:ga220858d2448c195cfcaca06516746db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the driver to signal that the driver is becoming Idle or active.  <a href="#ga220858d2448c195cfcaca06516746db9">More...</a><br/></td></tr>
<tr class="separator:ga220858d2448c195cfcaca06516746db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Device memory generic functions (SYS_Mem)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb4ded8c0a0d7b8376a7d8f9c793f12f1"></a>Memory management functions</p>
<p>Functions for allocating, freeing and getting CPU access.</p>
<p>Currently these do not do any checking that the read/write get/release behaviour matches up. In theory it would be possible to do GetReadPointer followed by release write pointer. This would result in device memory updates in both directions.</p>
<p>The Allocate function takes a hMemHandle, this allows it to know nothing about the driver context. </p>
</td></tr>
<tr class="memitem:ga6c455cdc8b2191c375c5cfb9b1bd05bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga6c455cdc8b2191c375c5cfb9b1bd05bb">SYS_MemAlloc</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiSize, struct <a class="el" href="struct_m_m_u_heap.html">MMUHeap</a> *pHeap, <a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a> ui32VirtualAlignment)</td></tr>
<tr class="memdesc:ga6c455cdc8b2191c375c5cfb9b1bd05bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a setted up memory structure and allocates its associated device memory.  <a href="#ga6c455cdc8b2191c375c5cfb9b1bd05bb">More...</a><br/></td></tr>
<tr class="separator:ga6c455cdc8b2191c375c5cfb9b1bd05bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47f202b305d3472b29de185dab69d38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gab47f202b305d3472b29de185dab69d38">SYS_MemFree</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:gab47f202b305d3472b29de185dab69d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Liberates memory allocated with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga6c455cdc8b2191c375c5cfb9b1bd05bb" title="Use a setted up memory structure and allocates its associated device memory. ">SYS_MemAlloc()</a> or <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gacf336107aefac0449721f39b3439c833" title="Import memory allocated outside - released when SYS_MemFree. ">SYS_MemImport()</a>  <a href="#gab47f202b305d3472b29de185dab69d38">More...</a><br/></td></tr>
<tr class="separator:gab47f202b305d3472b29de185dab69d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57659f5b506296107f2d97b71a2416ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga57659f5b506296107f2d97b71a2416ee">SYS_MemGetFirstAddress</a> (const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:ga57659f5b506296107f2d97b71a2416ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get 1st address of an allocation (1st virtual if allocated using MMU mapping or 1st physical otherwise)  <a href="#ga57659f5b506296107f2d97b71a2416ee">More...</a><br/></td></tr>
<tr class="separator:ga57659f5b506296107f2d97b71a2416ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930f937d14eba280a3a69f48e5f6f45a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga930f937d14eba280a3a69f48e5f6f45a">SYS_MemMap</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, struct <a class="el" href="struct_m_m_u_directory.html">MMUDirectory</a> *pDir, unsigned int flag)</td></tr>
<tr class="memdesc:ga930f937d14eba280a3a69f48e5f6f45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When mapping memory to the device MMU.  <a href="#ga930f937d14eba280a3a69f48e5f6f45a">More...</a><br/></td></tr>
<tr class="separator:ga930f937d14eba280a3a69f48e5f6f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99fe12e4a199127e3558389b1adbf5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaa99fe12e4a199127e3558389b1adbf5c">SYS_MemUnmap</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:gaa99fe12e4a199127e3558389b1adbf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To unmpa memory mapped with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga930f937d14eba280a3a69f48e5f6f45a" title="When mapping memory to the device MMU. ">SYS_MemMap()</a>  <a href="#gaa99fe12e4a199127e3558389b1adbf5c">More...</a><br/></td></tr>
<tr class="separator:gaa99fe12e4a199127e3558389b1adbf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf336107aefac0449721f39b3439c833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gacf336107aefac0449721f39b3439c833">SYS_MemImport</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiSize, struct <a class="el" href="struct_m_m_u_heap.html">MMUHeap</a> *pHeap, <a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a> ui32VirtualAlignment, int fd)</td></tr>
<tr class="memdesc:gacf336107aefac0449721f39b3439c833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import memory allocated outside - released when SYS_MemFree.  <a href="#gacf336107aefac0449721f39b3439c833">More...</a><br/></td></tr>
<tr class="separator:gacf336107aefac0449721f39b3439c833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cc61e1110b7c54935cb93f370a699b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga14cc61e1110b7c54935cb93f370a699b">SYS_MemRelease</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:ga14cc61e1110b7c54935cb93f370a699b"><td class="mdescLeft">&#160;</td><td class="mdescRight">release memory imported with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gacf336107aefac0449721f39b3439c833" title="Import memory allocated outside - released when SYS_MemFree. ">SYS_MemImport()</a>  <a href="#ga14cc61e1110b7c54935cb93f370a699b">More...</a><br/></td></tr>
<tr class="separator:ga14cc61e1110b7c54935cb93f370a699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81723a6ce82db80474ceb20b03705321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga81723a6ce82db80474ceb20b03705321">SYS_MemWriteWord</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiOff, <a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a> ui32Value)</td></tr>
<tr class="memdesc:ga81723a6ce82db80474ceb20b03705321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ui32Value into psMem+uiOffset.  <a href="#ga81723a6ce82db80474ceb20b03705321">More...</a><br/></td></tr>
<tr class="separator:ga81723a6ce82db80474ceb20b03705321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3e6b4c0a6159ae9824567bbe0deaa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gafd3e6b4c0a6159ae9824567bbe0deaa0">SYS_MemReadWord</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiOff, <a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a> *pui32Value)</td></tr>
<tr class="memdesc:gafd3e6b4c0a6159ae9824567bbe0deaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 32b value.  <a href="#gafd3e6b4c0a6159ae9824567bbe0deaa0">More...</a><br/></td></tr>
<tr class="separator:gafd3e6b4c0a6159ae9824567bbe0deaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145d1554b88aa72da3d1927b8fd9e47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga145d1554b88aa72da3d1927b8fd9e47d">SYS_MemWriteAddress</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiOffset, const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *pToWrite, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiToWriteOffset)</td></tr>
<tr class="memdesc:ga145d1554b88aa72da3d1927b8fd9e47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes pToWrite address+uiToWriteOffset into psMem+uiOffset.  <a href="#ga145d1554b88aa72da3d1927b8fd9e47d">More...</a><br/></td></tr>
<tr class="separator:ga145d1554b88aa72da3d1927b8fd9e47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c948245225d421e15a95886589e18f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga76c948245225d421e15a95886589e18f">SYS_MemWriteAddressToReg</a> (<a class="el" href="img__types_8h.html#aff5f25195b4ee313c3f4d203735090de">IMG_HANDLE</a> pTalRegHandle, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiOffset, const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *pToWrite, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiToWriteOffset)</td></tr>
<tr class="memdesc:ga76c948245225d421e15a95886589e18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes pToWrite+uiToWriteOffset into the registers.  <a href="#ga76c948245225d421e15a95886589e18f">More...</a><br/></td></tr>
<tr class="separator:ga76c948245225d421e15a95886589e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Platform System memory management functions (Platform_)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1d6005773dce9aab9d4e333c459938b7"></a>This is defined by the compiled allocator: TAL, ION or OS specific </p>
</td></tr>
<tr class="memitem:gaa352df003a24de6f5c39141a6e9e137a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaa352df003a24de6f5c39141a6e9e137a">Platform_MemAlloc</a> (<a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiRealAlloc, void *extra, <a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> *ret)</td></tr>
<tr class="memdesc:gaa352df003a24de6f5c39141a6e9e137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a bit of memory that does not have to be contiguous.  <a href="#gaa352df003a24de6f5c39141a6e9e137a">More...</a><br/></td></tr>
<tr class="separator:gaa352df003a24de6f5c39141a6e9e137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9afbf280b31356f1d8933869ec449732"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga9afbf280b31356f1d8933869ec449732">Platform_MemAllocContiguous</a> (<a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiRealAlloc, void *extra, <a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> *ret)</td></tr>
<tr class="memdesc:ga9afbf280b31356f1d8933869ec449732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a bit of memory that has to be contiguous.  <a href="#ga9afbf280b31356f1d8933869ec449732">More...</a><br/></td></tr>
<tr class="separator:ga9afbf280b31356f1d8933869ec449732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a0afc86bf3179321c4896b53bf7021e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga2a0afc86bf3179321c4896b53bf7021e">Platform_MemFree</a> (struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *psMem)</td></tr>
<tr class="memdesc:ga2a0afc86bf3179321c4896b53bf7021e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Liberate some allocated memory.  <a href="#ga2a0afc86bf3179321c4896b53bf7021e">More...</a><br/></td></tr>
<tr class="separator:ga2a0afc86bf3179321c4896b53bf7021e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac255d1b52429cb011f1c93c0d73f107e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gac255d1b52429cb011f1c93c0d73f107e">Platform_MemImport</a> (int fd, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> allocationSize, <a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> *ret)</td></tr>
<tr class="memdesc:gac255d1b52429cb011f1c93c0d73f107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports memory allocated by another source.  <a href="#gac255d1b52429cb011f1c93c0d73f107e">More...</a><br/></td></tr>
<tr class="separator:gac255d1b52429cb011f1c93c0d73f107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9b21232802a4b4d7bdaf1f59dcf57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga7b9b21232802a4b4d7bdaf1f59dcf57b">Platform_MemRelease</a> (struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *mem)</td></tr>
<tr class="memdesc:ga7b9b21232802a4b4d7bdaf1f59dcf57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release imported memory.  <a href="#ga7b9b21232802a4b4d7bdaf1f59dcf57b">More...</a><br/></td></tr>
<tr class="separator:ga7b9b21232802a4b4d7bdaf1f59dcf57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee265da624ee610a3e1381ba356b1f6e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaee265da624ee610a3e1381ba356b1f6e">Platform_MemGetMemory</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:gaee265da624ee610a3e1381ba356b1f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get CPU accessible memory.  <a href="#gaee265da624ee610a3e1381ba356b1f6e">More...</a><br/></td></tr>
<tr class="separator:gaee265da624ee610a3e1381ba356b1f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7697e9186818bbbb62f0d6d4f78c5b63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga7697e9186818bbbb62f0d6d4f78c5b63">Platform_MemUpdateHost</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:ga7697e9186818bbbb62f0d6d4f78c5b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should update CPU side memory in NUMA systems - does nothing on UMA systems.  <a href="#ga7697e9186818bbbb62f0d6d4f78c5b63">More...</a><br/></td></tr>
<tr class="separator:ga7697e9186818bbbb62f0d6d4f78c5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ebe7f9e5758e2d3a94e275673216323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga0ebe7f9e5758e2d3a94e275673216323">Platform_MemUpdateDevice</a> (<a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:ga0ebe7f9e5758e2d3a94e275673216323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should update Device side memory in NUMA systems - does nothing on UMA system.  <a href="#ga0ebe7f9e5758e2d3a94e275673216323">More...</a><br/></td></tr>
<tr class="separator:ga0ebe7f9e5758e2d3a94e275673216323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3f18a3d9cf2908066c116cbde78ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c99_2img__systypes_8h.html#a48056a52cf37d4ff43e300cd91b8ca25">IMG_UINT64</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gafa3f18a3d9cf2908066c116cbde78ba9">Platform_MemGetPhysPages</a> (const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem)</td></tr>
<tr class="memdesc:gafa3f18a3d9cf2908066c116cbde78ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the physical page list used for the allocation.  <a href="#gafa3f18a3d9cf2908066c116cbde78ba9">More...</a><br/></td></tr>
<tr class="separator:gafa3f18a3d9cf2908066c116cbde78ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad363e2c3f8a257dcdb805b0e2e2c6257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c99_2img__systypes_8h.html#a1a03c2490f0ee7227cecc2c7df4bfa20">IMG_UINTPTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gad363e2c3f8a257dcdb805b0e2e2c6257">Platform_MemGetDevMem</a> (const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiOff)</td></tr>
<tr class="memdesc:gad363e2c3f8a257dcdb805b0e2e2c6257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get physical device address (debug only?)  <a href="#gad363e2c3f8a257dcdb805b0e2e2c6257">More...</a><br/></td></tr>
<tr class="separator:gad363e2c3f8a257dcdb805b0e2e2c6257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1455cd807c9d56ead2ef2166d32c4e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga1455cd807c9d56ead2ef2166d32c4e45">Platform_MemMapUser</a> (struct <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, struct <a class="el" href="structvm__area__struct.html">vm_area_struct</a> *vma)</td></tr>
<tr class="memdesc:ga1455cd807c9d56ead2ef2166d32c4e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">use when mapping kernel-space memory to user-space (<a class="el" href="ci__ioctl__km_8c.html">ci_ioctl_km.c</a> IMG_CI_map())  <a href="#ga1455cd807c9d56ead2ef2166d32c4e45">More...</a><br/></td></tr>
<tr class="separator:ga1455cd807c9d56ead2ef2166d32c4e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f457b4a3a7b3d4ba1f9bbfca68b443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#aff5f25195b4ee313c3f4d203735090de">IMG_HANDLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga88f457b4a3a7b3d4ba1f9bbfca68b443">Platform_MemGetTalHandle</a> (const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *psMem, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> uiOffset, <a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> *pOff2)</td></tr>
<tr class="memdesc:ga88f457b4a3a7b3d4ba1f9bbfca68b443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the TAL HANDLE used when allocating memory to allow read/write to memory (or use memory to write to registers) in SYS_ functions.  <a href="#ga88f457b4a3a7b3d4ba1f9bbfca68b443">More...</a><br/></td></tr>
<tr class="separator:ga88f457b4a3a7b3d4ba1f9bbfca68b443"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Platform MMU memory management functions (Platform_)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfed2fa030276c0041f2060051089e7bc"></a>This is defined by the compiled allocator: TAL, ION or OS specific to manage the memory the MMU block will use</p>
<dl class="section note"><dt>Note</dt><dd>IMGMMU_pfnPageUpdateDevice is not implemented because it is assumed that the MMU memory is uncached and does not need flushing </dd></dl>
</td></tr>
<tr class="memitem:ga5f3d590c38dbc6ff88156db90939888a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga5f3d590c38dbc6ff88156db90939888a">Platform_MMU_MemPageAlloc</a> (void)</td></tr>
<tr class="memdesc:ga5f3d590c38dbc6ff88156db90939888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a page for the MMU mapping.  <a href="#ga5f3d590c38dbc6ff88156db90939888a">More...</a><br/></td></tr>
<tr class="separator:ga5f3d590c38dbc6ff88156db90939888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727d1af796fd97ccaa630fd8f1730f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga727d1af796fd97ccaa630fd8f1730f89">Platform_MMU_MemPageFree</a> (struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *pPub)</td></tr>
<tr class="memdesc:ga727d1af796fd97ccaa630fd8f1730f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a page used for MMU mapping.  <a href="#ga727d1af796fd97ccaa630fd8f1730f89">More...</a><br/></td></tr>
<tr class="separator:ga727d1af796fd97ccaa630fd8f1730f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae570968d6c18192ecfa88f3228b5c034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gae570968d6c18192ecfa88f3228b5c034">Platform_MMU_MemPageWrite</a> (struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *pWriteTo, unsigned int offset, <a class="el" href="c99_2img__systypes_8h.html#a48056a52cf37d4ff43e300cd91b8ca25">IMG_UINT64</a> uiToWrite, unsigned int flags)</td></tr>
<tr class="memdesc:gae570968d6c18192ecfa88f3228b5c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to use when writing to a page.  <a href="#gae570968d6c18192ecfa88f3228b5c034">More...</a><br/></td></tr>
<tr class="separator:gae570968d6c18192ecfa88f3228b5c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ec0d852bf8a19af48ffc0c7134b017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga06ec0d852bf8a19af48ffc0c7134b017">Platform_MMU_MemPageUpdate</a> (struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *pPage)</td></tr>
<tr class="memdesc:ga06ec0d852bf8a19af48ffc0c7134b017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to invalid CPU caches of MMU pages to ensure device can access them.  <a href="#ga06ec0d852bf8a19af48ffc0c7134b017">More...</a><br/></td></tr>
<tr class="separator:ga06ec0d852bf8a19af48ffc0c7134b017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Synchronisation (not interrupt-safe)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc2141135c9efe380077a998bf66b9f33"></a>Lock and semaphore that may sleep (not safe to use for ressources shared with interrupt handler). </p>
</td></tr>
<tr class="memitem:ga03be309a72856f530662db07019f1fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga03be309a72856f530662db07019f1fcb">SYS_LockInit</a> (<a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *pLock)</td></tr>
<tr class="memdesc:ga03be309a72856f530662db07019f1fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a lock object.  <a href="#ga03be309a72856f530662db07019f1fcb">More...</a><br/></td></tr>
<tr class="separator:ga03be309a72856f530662db07019f1fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c76b5264aa72db24a1d2bb9002a934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga21c76b5264aa72db24a1d2bb9002a934">SYS_LockDestroy</a> (<a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *pLock)</td></tr>
<tr class="memdesc:ga21c76b5264aa72db24a1d2bb9002a934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a lock object.  <a href="#ga21c76b5264aa72db24a1d2bb9002a934">More...</a><br/></td></tr>
<tr class="separator:ga21c76b5264aa72db24a1d2bb9002a934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5815f75a83228b25f87e72488eb86911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga5815f75a83228b25f87e72488eb86911">SYS_LockAcquire</a> (<a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *pLock) <a class="el" href="sys__parallel_8h.html#ae56358ccb6eefc3070af6da71fa7fb86">__acquires</a>(pLock)</td></tr>
<tr class="memdesc:ga5815f75a83228b25f87e72488eb86911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock.  <a href="#ga5815f75a83228b25f87e72488eb86911">More...</a><br/></td></tr>
<tr class="separator:ga5815f75a83228b25f87e72488eb86911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287389495b605dc6e7f983b36a9b7450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga287389495b605dc6e7f983b36a9b7450">SYS_LockRelease</a> (<a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *pLock) <a class="el" href="sys__parallel_8h.html#ae26d9f461fdaaa722065373c31f42d37">__releases</a>(pLock)</td></tr>
<tr class="memdesc:ga287389495b605dc6e7f983b36a9b7450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the lock.  <a href="#ga287389495b605dc6e7f983b36a9b7450">More...</a><br/></td></tr>
<tr class="separator:ga287389495b605dc6e7f983b36a9b7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63057eb9d12a869c90322d437ae021f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gab63057eb9d12a869c90322d437ae021f">SYS_SemInit</a> (<a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *ppSem, int i32InitValue)</td></tr>
<tr class="memdesc:gab63057eb9d12a869c90322d437ae021f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a semaphore object and initialise it.  <a href="#gab63057eb9d12a869c90322d437ae021f">More...</a><br/></td></tr>
<tr class="separator:gab63057eb9d12a869c90322d437ae021f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac27a9c39d246889fc040f814367c9081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gac27a9c39d246889fc040f814367c9081">SYS_SemIncrement</a> (<a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *pSem)</td></tr>
<tr class="memdesc:gac27a9c39d246889fc040f814367c9081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the value of the semaphore (and wakes up waiting processes)  <a href="#gac27a9c39d246889fc040f814367c9081">More...</a><br/></td></tr>
<tr class="separator:gac27a9c39d246889fc040f814367c9081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86b3870944dc793358539e727380429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gae86b3870944dc793358539e727380429">SYS_SemDecrement</a> (<a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *pSem)</td></tr>
<tr class="memdesc:gae86b3870944dc793358539e727380429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps until a semaphore value can be tacken.  <a href="#gae86b3870944dc793358539e727380429">More...</a><br/></td></tr>
<tr class="separator:gae86b3870944dc793358539e727380429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d703b3ea6ec24a24efa63c28336c81e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga5d703b3ea6ec24a24efa63c28336c81e">SYS_SemTimedDecrement</a> (<a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *pSem, unsigned int timeoutMs)</td></tr>
<tr class="memdesc:ga5d703b3ea6ec24a24efa63c28336c81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps until a semaphore value can be taken or timeoutMs ms passed.  <a href="#ga5d703b3ea6ec24a24efa63c28336c81e">More...</a><br/></td></tr>
<tr class="separator:ga5d703b3ea6ec24a24efa63c28336c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468294c5580cdac8e0b25c0209f4af5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga468294c5580cdac8e0b25c0209f4af5e">SYS_SemTryDecrement</a> (<a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *pSem)</td></tr>
<tr class="memdesc:ga468294c5580cdac8e0b25c0209f4af5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to decrement the semaphore but does not sleep.  <a href="#ga468294c5580cdac8e0b25c0209f4af5e">More...</a><br/></td></tr>
<tr class="separator:ga468294c5580cdac8e0b25c0209f4af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f40dfb145526e28ab078cfebe159ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gae2f40dfb145526e28ab078cfebe159ea">SYS_SemDestroy</a> (<a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *pSem)</td></tr>
<tr class="memdesc:gae2f40dfb145526e28ab078cfebe159ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the semaphore.  <a href="#gae2f40dfb145526e28ab078cfebe159ea">More...</a><br/></td></tr>
<tr class="separator:gae2f40dfb145526e28ab078cfebe159ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Synchronisation (interrupt-safe)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe431bcda1f5e145cabb45edf9dd262a1"></a>Locks that are safe to use when ressource is shared with the interrupt handler (spinlock) </p>
</td></tr>
<tr class="memitem:ga8260d29e1c920cfcc08dbb484500890c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga8260d29e1c920cfcc08dbb484500890c">SYS_SpinlockInit</a> (<a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *pLock)</td></tr>
<tr class="memdesc:ga8260d29e1c920cfcc08dbb484500890c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a lock object.  <a href="#ga8260d29e1c920cfcc08dbb484500890c">More...</a><br/></td></tr>
<tr class="separator:ga8260d29e1c920cfcc08dbb484500890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0d6b5b94dd509e8463a1bb3f874453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaeb0d6b5b94dd509e8463a1bb3f874453">SYS_SpinlockDestroy</a> (<a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *pLock)</td></tr>
<tr class="memdesc:gaeb0d6b5b94dd509e8463a1bb3f874453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a lock object.  <a href="#gaeb0d6b5b94dd509e8463a1bb3f874453">More...</a><br/></td></tr>
<tr class="separator:gaeb0d6b5b94dd509e8463a1bb3f874453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075a56a9bce68cb802e60c51c1f1f30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga075a56a9bce68cb802e60c51c1f1f30f">SYS_SpinlockAcquire</a> (<a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *pLock) <a class="el" href="sys__parallel_8h.html#ae56358ccb6eefc3070af6da71fa7fb86">__acquires</a>(&amp;(pLock-&gt; sLock))</td></tr>
<tr class="memdesc:ga075a56a9bce68cb802e60c51c1f1f30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock - interrupts are safely disabled beforehand.  <a href="#ga075a56a9bce68cb802e60c51c1f1f30f">More...</a><br/></td></tr>
<tr class="separator:ga075a56a9bce68cb802e60c51c1f1f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ae407f4bcb2f64147fdba0bbf44842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga43ae407f4bcb2f64147fdba0bbf44842">SYS_SpinlockRelease</a> (<a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *pLock) <a class="el" href="sys__parallel_8h.html#ae26d9f461fdaaa722065373c31f42d37">__releases</a>(&amp;(pLock-&gt; sLock))</td></tr>
<tr class="memdesc:ga43ae407f4bcb2f64147fdba0bbf44842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the lock - interrupts are restored after release.  <a href="#ga43ae407f4bcb2f64147fdba0bbf44842">More...</a><br/></td></tr>
<tr class="separator:ga43ae407f4bcb2f64147fdba0bbf44842"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Kernel-side tools. </p>
<p>Defines functionalities that are dependent on the system the driver was compiled for (e.g. memory access) </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga7a5844a2a08494e94ba6566f69139ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a>  <a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the information the driver needs about a device. </p>

</div>
</div>
<a class="anchor" id="ga817c9065bead40cb1a3a1e965ab3b2a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="sys__device_8h.html#a33561b7274066c2fe0a180a2ae633f5c">irq_handler_t</a> <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga817c9065bead40cb1a3a1e965ab3b2a3">SYS_IRQ_HANDLER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1fc149801e296f00c0989cf4f0e859c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a>  <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>opaque type defined by allocator </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga91341ae6fc329f6dc28a12b90729ba4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga91341ae6fc329f6dc28a12b90729ba4e">SYS_MEM_UPD</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga91341ae6fc329f6dc28a12b90729ba4eaf644bb7bcb359670f109afdbfd3aa0d9"></a>SYS_MEM_UPD_HOST</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga91341ae6fc329f6dc28a12b90729ba4ea339b8758444e609936891e4f9c6edb12"></a>SYS_MEM_UPD_DEV</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa352df003a24de6f5c39141a6e9e137a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a>* Platform_MemAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiRealAlloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a bit of memory that does not have to be contiguous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiRealAlloc</td><td>size in Bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extra</td><td>additional information needed when using Fake driver (base TAL handle for the memory) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>result (IMG_SUCCESS or other)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new allocation or NULL if failed and ret contains a return code</dd></dl>
<p>See <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga9afbf280b31356f1d8933869ec449732">Platform_MemAllocContiguous()</a> </p>

</div>
</div>
<a class="anchor" id="ga9afbf280b31356f1d8933869ec449732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a>* Platform_MemAllocContiguous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiRealAlloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a bit of memory that has to be contiguous. </p>
<p>Memory will be released with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga2a0afc86bf3179321c4896b53bf7021e" title="Liberate some allocated memory. ">Platform_MemFree()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiRealAlloc</td><td>size in Bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extra</td><td>additional information needed when using Fake driver (base TAL handle for the memory) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>result (IMG_SUCCESS or other)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new allocation or NULL if failed and ret contains a return code</dd></dl>
<p>See <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaa352df003a24de6f5c39141a6e9e137a">Platform_MemAlloc()</a> </p>

</div>
</div>
<a class="anchor" id="ga2a0afc86bf3179321c4896b53bf7021e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Platform_MemFree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Liberate some allocated memory. </p>

</div>
</div>
<a class="anchor" id="gad363e2c3f8a257dcdb805b0e2e2c6257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c99_2img__systypes_8h.html#a1a03c2490f0ee7227cecc2c7df4bfa20">IMG_UINTPTR</a> Platform_MemGetDevMem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get physical device address (debug only?) </p>

</div>
</div>
<a class="anchor" id="gaee265da624ee610a3e1381ba356b1f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Platform_MemGetMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get CPU accessible memory. </p>

</div>
</div>
<a class="anchor" id="gafa3f18a3d9cf2908066c116cbde78ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c99_2img__systypes_8h.html#a48056a52cf37d4ff43e300cd91b8ca25">IMG_UINT64</a>* Platform_MemGetPhysPages </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the physical page list used for the allocation. </p>
<p>Should contain allocSize/PAGE_SIZE elements</p>
<dl class="section note"><dt>Note</dt><dd>May need some cleaning in the future (current allocator returns the actual list not a copy so no cleaning needed!) </dd></dl>

</div>
</div>
<a class="anchor" id="ga88f457b4a3a7b3d4ba1f9bbfca68b443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#aff5f25195b4ee313c3f4d203735090de">IMG_HANDLE</a> Platform_MemGetTalHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a> *&#160;</td>
          <td class="paramname"><em>pOff2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to the TAL HANDLE used when allocating memory to allow read/write to memory (or use memory to write to registers) in SYS_ functions. </p>
<p>When using Fake driver this should return the TAL handle for the page to write into. If the allocation is virtual will return the actual page in the list and pOff2 will be set to the offset in that page.</p>
<p>For real driver the memory should be mapped to the CPU and so that the CPU virtual address is linear. Therefore this function should return the CPU virtual address and pOff2 should be the same than uiOffset</p>
<p>Example with fake driver: </p>
<ul>
<li>allocation of 7kB of memory will result in 2 pages allocation (2*4k = 8k): page 0 and page 1 </li>
<li>access to offset 1000 in the memory will need to access to page 0, offset 1000 </li>
<li>access to offset 5000 in the memory will need to access to page 1, offset 904</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psMem</td><td>allocated memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiOffset</td><td>offset in the memory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOff2</td><td>offset in the memory after transformation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>memory handle for the TAL </dd></dl>

</div>
</div>
<a class="anchor" id="gac255d1b52429cb011f1c93c0d73f107e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a>* Platform_MemImport </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>allocationSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports memory allocated by another source. </p>
<p>Memory will be released with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga7b9b21232802a4b4d7bdaf1f59dcf57b" title="Release imported memory. ">Platform_MemRelease()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to import </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocationSize</td><td>size of the imported memory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>result (IMG_SUCCESS or other)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new allocation or NULL if failed and ret contains a return code </dd></dl>

</div>
</div>
<a class="anchor" id="ga1455cd807c9d56ead2ef2166d32c4e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> Platform_MemMapUser </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structvm__area__struct.html">vm_area_struct</a> *&#160;</td>
          <td class="paramname"><em>vma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use when mapping kernel-space memory to user-space (<a class="el" href="ci__ioctl__km_8c.html">ci_ioctl_km.c</a> IMG_CI_map()) </p>
<p>@ add remap function and open and close to support forking </p>

</div>
</div>
<a class="anchor" id="ga7b9b21232802a4b4d7bdaf1f59dcf57b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Platform_MemRelease </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_s_y_s___m_e_m___a_l_l_o_c.html">SYS_MEM_ALLOC</a> *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release imported memory. </p>

</div>
</div>
<a class="anchor" id="ga0ebe7f9e5758e2d3a94e275673216323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> Platform_MemUpdateDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should update Device side memory in NUMA systems - does nothing on UMA system. </p>

</div>
</div>
<a class="anchor" id="ga7697e9186818bbbb62f0d6d4f78c5b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> Platform_MemUpdateHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should update CPU side memory in NUMA systems - does nothing on UMA systems. </p>

</div>
</div>
<a class="anchor" id="ga5f3d590c38dbc6ff88156db90939888a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a>* Platform_MMU_MemPageAlloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a page for the MMU mapping. </p>
<p>Should implement IMGMMU_pfnPageAlloc </p>

</div>
</div>
<a class="anchor" id="ga727d1af796fd97ccaa630fd8f1730f89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Platform_MMU_MemPageFree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *&#160;</td>
          <td class="paramname"><em>pPub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a page used for MMU mapping. </p>
<p>Should implement IMGMMU_pfnPageFree </p>

</div>
</div>
<a class="anchor" id="ga06ec0d852bf8a19af48ffc0c7134b017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Platform_MMU_MemPageUpdate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *&#160;</td>
          <td class="paramname"><em>pPage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to invalid CPU caches of MMU pages to ensure device can access them. </p>
<p>Should implement IMGMMU_pfnPageUpdate </p>

</div>
</div>
<a class="anchor" id="gae570968d6c18192ecfa88f3228b5c034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Platform_MMU_MemPageWrite </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_m_m_u_page.html">MMUPage</a> *&#160;</td>
          <td class="paramname"><em>pWriteTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#a48056a52cf37d4ff43e300cd91b8ca25">IMG_UINT64</a>&#160;</td>
          <td class="paramname"><em>uiToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to use when writing to a page. </p>
<p>Should implement IMGMMU_pfnPageWrite </p>

</div>
</div>
<a class="anchor" id="ga0743d654f5183789aca5ad04a6449db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevClearInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement that function if the device needs to clear more registers than the felix ones when receiving an interrupt. </p>
<p>@ use container_of to get the PCIDriver rather than globals </p>

</div>
</div>
<a class="anchor" id="ga1d60e5f2e6efba3b19815af8a1de1995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevDeregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ use container_of to get the PCIDriver rather than using global </p>

</div>
</div>
<a class="anchor" id="gacdbc14a65db2afc6a6343e4c69dd4427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevFreeIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an aquired interrupt (if not acquired then nothing happens) </p>
<p>@ use container_of to fing the PCIDriver rather than the global </p>

</div>
</div>
<a class="anchor" id="ga220858d2448c195cfcaca06516746db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevPowerControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="img__types_8h.html#ad54d51a0bf32d3d4f88806da34198b79">IMG_BOOL8</a>&#160;</td>
          <td class="paramname"><em>bDeviceActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the driver to signal that the driver is becoming Idle or active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDevice</td><td></td></tr>
    <tr><td class="paramname">bDeviceActive</td><td>IMG_TRUE if the device needs to become active (power ON) or IMG_FALSE if the device can become inactive (power OFF)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IMG_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="gadcc8f0ef3328a61819150907e0f4b8cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4d6bb33f15beb4bea67667c7556885e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevRemove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the kernel module is removed. </p>

</div>
</div>
<a class="anchor" id="gadd66adf1947f3950f4c7b5360e6f7740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_DevRequestIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___d_e_v_i_c_e.html">SYS_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the IRQ associated with the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDevice</td><td>the device </td></tr>
    <tr><td class="paramname">pszName</td><td>name of the handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IMG_SUCCESS if the interrupt was acquired </dd>
<dd>
IMG_ERROR_UNEXPECTED_STATE if the interrupt could not be acquired at that time </dd></dl>
<p>@ use container_of to get the PCIDriver rather than using global </p>

</div>
</div>
<a class="anchor" id="ga5815f75a83228b25f87e72488eb86911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_LockAcquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the lock. </p>
<dl class="section warning"><dt>Warning</dt><dd>does NOT uses re-entrant lock </dd></dl>

</div>
</div>
<a class="anchor" id="ga21c76b5264aa72db24a1d2bb9002a934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_LockDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a lock object. </p>
<dl class="section warning"><dt>Warning</dt><dd>if LockCreate was called use need to call IMG_FREE on it </dd></dl>

</div>
</div>
<a class="anchor" id="ga03be309a72856f530662db07019f1fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_LockInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a lock object. </p>
<dl class="section warning"><dt>Warning</dt><dd>does NOT creates a re-entrant lock </dd></dl>

</div>
</div>
<a class="anchor" id="ga287389495b605dc6e7f983b36a9b7450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_LockRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___l_o_c_k.html">SYS_LOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the lock. </p>
<dl class="section warning"><dt>Warning</dt><dd>does NOT uses re-entrant lock </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c455cdc8b2191c375c5cfb9b1bd05bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_m_m_u_heap.html">MMUHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a>&#160;</td>
          <td class="paramname"><em>ui32VirtualAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a setted up memory structure and allocates its associated device memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMem</td><td></td></tr>
    <tr><td class="paramname">uiSize</td><td>allocation size (in bytes) </td></tr>
    <tr><td class="paramname">pHeap</td><td>heap to use to allocate device virtual address (if using MMU) </td></tr>
    <tr><td class="paramname">ui32VirtualAlignment</td><td>allocates additional virtual memory to cope with possible alignment (e.g. for tiling 1st first address has to be aligned to a defined value)</td></tr>
  </table>
  </dd>
</dl>
<p>The allocation size is rounded up using SYSMEM_ALIGNMENT.</p>
<p>If CI_MEMSET_ALIGNMENT is defined the additional memory will be set using this value.</p>
<dl class="section return"><dt>Returns</dt><dd>IMG_SUCCESS </dd>
<dd>
IMG_ERROR_INVALID_PARAMETER if psMem is NULL or some of its parameters are invalid </dd>
<dd>
IMG_ERROR_MEMORY_IN_USE if psMem-&gt;hMem or psMem-&gt;pvCpuLin is not NULL </dd>
<dd>
IMG_ERROR_NOT_SUPPORTED if the driver global pointer is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gab47f202b305d3472b29de185dab69d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Liberates memory allocated with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga6c455cdc8b2191c375c5cfb9b1bd05bb" title="Use a setted up memory structure and allocates its associated device memory. ">SYS_MemAlloc()</a> or <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gacf336107aefac0449721f39b3439c833" title="Import memory allocated outside - released when SYS_MemFree. ">SYS_MemImport()</a> </p>

</div>
</div>
<a class="anchor" id="ga57659f5b506296107f2d97b71a2416ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a> SYS_MemGetFirstAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get 1st address of an allocation (1st virtual if allocated using MMU mapping or 1st physical otherwise) </p>

</div>
</div>
<a class="anchor" id="gacf336107aefac0449721f39b3439c833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_m_m_u_heap.html">MMUHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a>&#160;</td>
          <td class="paramname"><em>ui32VirtualAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import memory allocated outside - released when SYS_MemFree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">psMem</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">uiSize</td><td>in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHeap</td><td>virtual memory heap to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ui32VirtualAlignment</td><td>allocates additional virtual memory to cope with possible alignment (e.g. for tiling 1st first address has to be aligned to a defined value) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fd</td><td>import mechanism ID to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga930f937d14eba280a3a69f48e5f6f45a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_m_m_u_directory.html">MMUDirectory</a> *&#160;</td>
          <td class="paramname"><em>pDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When mapping memory to the device MMU. </p>

</div>
</div>
<a class="anchor" id="gafd3e6b4c0a6159ae9824567bbe0deaa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemReadWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a> *&#160;</td>
          <td class="paramname"><em>pui32Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a 32b value. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga7697e9186818bbbb62f0d6d4f78c5b63" title="Should update CPU side memory in NUMA systems - does nothing on UMA systems. ">Platform_MemUpdateHost()</a> may need to be called before or after this function!</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can be done using <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaee265da624ee610a3e1381ba356b1f6e" title="Get CPU accessible memory. ">Platform_MemGetMemory()</a> and then reading from the correct offset. But this solution is writing pdumps when running FELIX_FAKE </dd></dl>

</div>
</div>
<a class="anchor" id="ga14cc61e1110b7c54935cb93f370a699b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release memory imported with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gacf336107aefac0449721f39b3439c833" title="Import memory allocated outside - released when SYS_MemFree. ">SYS_MemImport()</a> </p>

</div>
</div>
<a class="anchor" id="gaa99fe12e4a199127e3558389b1adbf5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemUnmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To unmpa memory mapped with <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga930f937d14eba280a3a69f48e5f6f45a" title="When mapping memory to the device MMU. ">SYS_MemMap()</a> </p>

</div>
</div>
<a class="anchor" id="ga145d1554b88aa72da3d1927b8fd9e47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemWriteAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>pToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiToWriteOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes pToWrite address+uiToWriteOffset into psMem+uiOffset. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaee265da624ee610a3e1381ba356b1f6e" title="Get CPU accessible memory. ">Platform_MemGetMemory()</a> and <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga0ebe7f9e5758e2d3a94e275673216323" title="Should update Device side memory in NUMA systems - does nothing on UMA system. ">Platform_MemUpdateDevice()</a> still need to be called before or after this function!</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can be done using <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaee265da624ee610a3e1381ba356b1f6e" title="Get CPU accessible memory. ">Platform_MemGetMemory()</a> and then writing to the correct offset. But this solution is writing pdumps when running FELIX_FAKE </dd></dl>

</div>
</div>
<a class="anchor" id="ga76c948245225d421e15a95886589e18f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemWriteAddressToReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="img__types_8h.html#aff5f25195b4ee313c3f4d203735090de">IMG_HANDLE</a>&#160;</td>
          <td class="paramname"><em>pTalRegHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>pToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiToWriteOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes pToWrite+uiToWriteOffset into the registers. </p>
<dl class="section warning"><dt>Warning</dt><dd>Platform_MemUpdateDevice still need to be called before or after this function to ensure the HW has access to the correct memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga81723a6ce82db80474ceb20b03705321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_MemWriteWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___m_e_m.html">SYS_MEM</a> *&#160;</td>
          <td class="paramname"><em>psMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#ad5f3a7e6e4536c6ad1e756b4f06ccecb">IMG_SIZE</a>&#160;</td>
          <td class="paramname"><em>uiOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c99_2img__systypes_8h.html#afbbcd3ca36cd3bc43d459488cfb99071">IMG_UINT32</a>&#160;</td>
          <td class="paramname"><em>ui32Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes ui32Value into psMem+uiOffset. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga0ebe7f9e5758e2d3a94e275673216323" title="Should update Device side memory in NUMA systems - does nothing on UMA system. ">Platform_MemUpdateDevice()</a> may need to be called before or after this function!</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can be done using <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#gaee265da624ee610a3e1381ba356b1f6e" title="Get CPU accessible memory. ">Platform_MemGetMemory()</a> and then writing to the correct offset. But this solution is writing pdumps when running FELIX_FAKE</dd>
<dd>
Uses <a class="el" href="group___c_i___k_e_r_n_e_l___t_o_o_l_s.html#ga88f457b4a3a7b3d4ba1f9bbfca68b443" title="Access to the TAL HANDLE used when allocating memory to allow read/write to memory (or use memory to ...">Platform_MemGetTalHandle()</a> to get </dd></dl>

</div>
</div>
<a class="anchor" id="gae86b3870944dc793358539e727380429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SemDecrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *&#160;</td>
          <td class="paramname"><em>pSem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleeps until a semaphore value can be tacken. </p>
<dl class="section return"><dt>Returns</dt><dd>IMG_SUCCESS when acquiring a token </dd>
<dd>
IMG_ERROR_INTERRUPTED if interrupted by signals/interrupts </dd>
<dd>
IMG_ERROR_FATAL on other errors </dd></dl>

</div>
</div>
<a class="anchor" id="gae2f40dfb145526e28ab078cfebe159ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SemDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *&#160;</td>
          <td class="paramname"><em>pSem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the semaphore. </p>
<dl class="section warning"><dt>Warning</dt><dd>destroying a semaphore some processes are waiting on has undefined effect </dd></dl>

</div>
</div>
<a class="anchor" id="gac27a9c39d246889fc040f814367c9081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SemIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *&#160;</td>
          <td class="paramname"><em>pSem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the value of the semaphore (and wakes up waiting processes) </p>

</div>
</div>
<a class="anchor" id="gab63057eb9d12a869c90322d437ae021f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SemInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *&#160;</td>
          <td class="paramname"><em>ppSem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i32InitValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a semaphore object and initialise it. </p>

</div>
</div>
<a class="anchor" id="ga5d703b3ea6ec24a24efa63c28336c81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SemTimedDecrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *&#160;</td>
          <td class="paramname"><em>pSem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleeps until a semaphore value can be taken or timeoutMs ms passed. </p>
<dl class="section return"><dt>Returns</dt><dd>IMG_SUCCESS </dd>
<dd>
IMG_ERROR_TIMEOUT on timeout </dd>
<dd>
IMG_ERROR_FATAL on other reasons the decrement failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga468294c5580cdac8e0b25c0209f4af5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SemTryDecrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys__parallel_8h.html#a23d02dbfa9917d0c486d9f8d94b59d86">SYS_SEM</a> *&#160;</td>
          <td class="paramname"><em>pSem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to decrement the semaphore but does not sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>IMG_SUCCESS if semaphore was decremented </dd>
<dd>
IMG_ERROR_CANCELLED if the semaphore could not be acquired </dd></dl>

</div>
</div>
<a class="anchor" id="ga075a56a9bce68cb802e60c51c1f1f30f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SpinlockAcquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td> -&gt;  sLock))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the lock - interrupts are safely disabled beforehand. </p>
<dl class="section warning"><dt>Warning</dt><dd>does NOT uses re-entrant lock </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb0d6b5b94dd509e8463a1bb3f874453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SpinlockDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a lock object. </p>
<dl class="section warning"><dt>Warning</dt><dd>if LockCreate was called use need to call IMG_FREE on it </dd></dl>

</div>
</div>
<a class="anchor" id="ga8260d29e1c920cfcc08dbb484500890c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SpinlockInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a lock object. </p>
<dl class="section warning"><dt>Warning</dt><dd>does NOT creates a re-entrant lock </dd></dl>

</div>
</div>
<a class="anchor" id="ga43ae407f4bcb2f64147fdba0bbf44842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="img__types_8h.html#acbbd12329a0023857600682f4fdfc05c">IMG_RESULT</a> SYS_SpinlockRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_y_s___s_p_i_n_l_o_c_k.html">SYS_SPINLOCK</a> *&#160;</td>
          <td class="paramname"><em>pLock</em></td><td>)</td>
          <td> -&gt;  sLock))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the lock - interrupts are restored after release. </p>
<dl class="section warning"><dt>Warning</dt><dd>does NOT uses re-entrant lock </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="footer">
    &copy; Copyright 2016, Imagination Technologies.
</div>
<!-- Back-to-top -->
<a href="#" class="back-to-top">&#8593; TOP</a>
<script>            
    jQuery(document).ready(function() {
    var offset = 220;
        var duration = 500;
        jQuery(window).scroll(function() {
            if (jQuery(this).scrollTop() > offset) {
                jQuery('.back-to-top').fadeIn(duration);
            } else {
                jQuery('.back-to-top').fadeOut(duration);
            }
        });
        jQuery('.back-to-top').click(function(event) {
            event.preventDefault();
            jQuery('html, body').animate({scrollTop: 0}, duration);
            return false;
        })
    });
</script>
<!-- End Back-to-top -->
</body>
</html>
